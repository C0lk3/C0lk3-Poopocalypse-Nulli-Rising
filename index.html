<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üòà Poopocalypse: Nulli Rising üßô</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;700&family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.52/Tone.js"></script>
    
    <style>
        /* --- General Variables & Body --- */
        :root {
            --dark-bg: #1a1a2e; /* Dark Navy/Purple */
            --card-bg: #2d2d44; /* Darker Card Background */
            --neon-green: #00f800;
            --gold-title: #ffcc00;
            --text-color: #ffffff;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            margin: 0;
            transition: background-color 0.5s;
        }

        /* --- Launcher Card Styles --- */
        #launcherContainer {
            background-color: var(--card-bg);
            border: 4px solid var(--neon-green);
            box-shadow: 0 10px 30px rgba(0, 255, 0, 0.4);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }
        .main-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            color: var(--gold-title);
            text-shadow: 2px 2px 0 #000000;
            margin-bottom: 1.5rem;
        }
        .description {
            font-size: 0.9rem;
            margin-bottom: 2.5rem;
            color: #c0c0c0;
            line-height: 1.6;
        }
        .launch-button {
            padding: 1rem 2.5rem;
            font-size: 1.1rem;
            font-weight: 700;
            color: black;
            background: linear-gradient(145deg, var(--neon-green), #18a558);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 4px #006400;
            text-transform: uppercase;
        }
        .launch-button:hover {
            background: linear-gradient(145deg, #39ff14, #24d673);
            transform: translateY(-2px);
            box-shadow: 0 6px #006400;
        }
        .launch-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px #006400;
        }

        /* --- Game Container Styles (starts hidden) --- */
        #gameContainer {
            display: none; /* Initially hidden */
            background-color: #2d2d44;
            border: 6px solid #00f800;
            box-shadow: 0 8px 20px rgba(0, 255, 0, 0.4);
            border-radius: 18px;
            padding: 0.5rem; 
            max-width: 320px; 
            width: 100%;
            flex-direction: column;
            align-items: center;
            font-family: 'Pixelify Sans', sans-serif;
        }
        canvas {
            display: block;
            background-color: #4a148c; /* Deep Violet Canvas */
            border: 3px solid #ffeb3b; /* Yellow/Gold Inner Border */
            border-radius: 10px;
            margin-top: 0.5rem;
            touch-action: none; /* Prevents touch scrolling/panning interference */
        }
        .info-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0.4rem 0.2rem; 
            font-size: 1rem; 
            font-weight: 700;
            color: #ffffff;
        }
        .game-title {
            font-family: 'Press Start 2P', cursive; 
            font-size: 1.2rem; 
            color: #00f800; 
            text-shadow: 3px 3px 0 #000000; 
            line-height: 1.4;
        }
        .button {
            padding: 0.5rem 1rem; 
            font-size: 0.9rem; 
            font-weight: 700;
            color: black; 
            background: linear-gradient(145deg, #fceb9c, #ffcc00); 
            border: none;
            border-radius: 8px; 
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: 0 3px #cc9900;
            user-select: none;
        }
        /* Styles for Game Over/Message Box */
        .button-llm {
            background: linear-gradient(145deg, #00f800, #18a558); 
            box-shadow: 0 3px #006400;
            color: black;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #00f800;
            border-radius: 50%;
            width: 1.2rem;
            height: 1.2rem;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 0.5rem;
        }
        
        #messageBox {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            font-family: 'Pixelify Sans', sans-serif; 
            display: none;
        }
        #messageBox > div {
            max-width: 90%;
            padding: 15px;
            background-color: #1a1a2e; 
            border: 2px solid #00f800;
            border-radius: 12px;
            width: 90%; /* Ensure it's responsive */
            max-width: 380px;
        }
        #messageBox h2 {
            font-family: 'Press Start 2P', cursive; 
            font-size: 1.4rem; 
            margin-bottom: 0.5rem;
            color: #ffcc00; 
        }
        .leaderboard-card {
            background-color: #1a1a2e; 
            border: 2px solid #00f800; 
            border-radius: 10px;
            padding: 0.4rem; 
            margin-top: 0.75rem;
            width: 100%;
        }
        #highScoresTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem; 
        }
        #highScoresTable th {
            background-color: #4a148c; 
            color: #ffcc00; 
            padding: 0.3rem; 
            text-align: left;
            font-family: 'Press Start 2P', cursive; 
        }
        #highScoresTable td {
            border-bottom: 1px solid #4a148c;
            color: #c0c0c0; 
            padding: 0.3rem;
        }
        
        /* Responsive adjustments */
        @media (max-width: 640px) {
            .main-title {
                font-size: 1.2rem;
            }
            #launcherContainer {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>

<!-- --- 1. THE LAUNCHER CONTAINER (Initially Visible) --- -->
<div id="launcherContainer" class="flex flex-col">
    <div class="main-title">üòà POOPOCALYPSE: NULLI RISING üßô</div>

    <p class="description">
        The dreaded Nulli Clan is on the rise! Play as the heroic collector üòã in this arcade survival game. Dodge Jehannum's repulsive üí© and collect vital treats (üç¨, üç≠) to survive the Poopocalypse. The leaderboard is shared with all players, so strive for the highest score!
    </p>

    <button id="launchButton" class="launch-button">
        Launch Game Now!
    </button>
</div>

<!-- --- 2. THE GAME CONTAINER (Initially Hidden) --- -->
<div id="gameContainer" class="game-container">
    <h1 class="game-title">üòà POOPOCALYPSE: NULLI RISING üßô</h1>
    
    <div class="info-bar">
        <span>Score: <span id="scoreDisplay">0</span></span>
        <span>Lives: <span id="livesDisplay">‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è</span></span>
    </div>

    <canvas id="gameCanvas" width="280" height="280"></canvas>
    
    <div class="leaderboard-card">
        <h2 class="text-base font-bold text-center text-yellow-500 mb-1 font-['Press Start 2P']">üèÜ Top Sweet Collectors üèÜ</h2>
        <table id="highScoresTable">
            <thead>
                <tr>
                    <th class="rounded-tl-lg">Rank</th>
                    <th>Name</th>
                    <th class="rounded-tr-lg text-right">Score</th>
                </tr>
            </thead>
            <tbody id="highScoresBody">
                <tr><td colspan="3" class="text-center py-2 text-gray-500">Initializing database...</td></tr>
            </tbody>
        </table>
    </div>
</div>

<!-- --- 3. MESSAGE BOX (Game Over / Intro) --- -->
<div id="messageBox">
    <div>
        <h2 id="messageTitle"></h2>
        
        <div id="llmResponseContainer" class="mt-3 hidden">
            <div id="clanLabel" class="text-sm font-bold text-yellow-500 mb-1">Final Word from the Clan:</div> 
            <p id="llmResponseText" class="text-xs text-left p-2 rounded bg-purple-900/50 border border-yellow-700"></p>
        </div>
        
        <p id="messageText" class="mt-3 mb-0"></p>
        
        <div id="buttonArea" class="flex flex-col md:flex-row justify-center items-center gap-2 mt-4">
            <!-- Buttons dynamically inserted here -->
        </div>
    </div>
</div>

<!-- --- 4. MAIN GAME SCRIPT (Module) --- -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, onSnapshot, query, where, serverTimestamp, doc, setDoc, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // --- PRE-WRITTEN DIALOGUE (omitted for brevity) ---
    const PRE_WRITTEN_DIALOGUE = {
        high: [
            "Your score is a testament to the divine light! The FA Clan celebrates this monumental sweep of sweetness. Truly a glorious day!",
            "Such grace and dedication! You've soared above the Nulli filth. Keep collecting, for the celestial hoard is ever expanding!",
            "A magnificent feat! You are a beacon of hope against the Poopocalypse. The heavens smile upon your high score of collected treats.",
            "Mandala is impressed! This score is a prayer answered, a perfect harmony of skill and luck. Go forth and shine!",
            "Hark! The Nulli Clan trembles at this total. You have proven that virtue is stronger than vile stench. Excellent work!",
            "Look at those numbers! An ethereal harvest! May your next run bring even greater glory to the FA Clan's cause.",
            "You have achieved true purity of purpose. This high score ensures your name is sung throughout the halls of the heavens!",
            "Divine! The Nulli's attempts were futile against such masterful collection. Keep your spirit bright and your bucket full!",
            "I grant you my blessing for this outstanding result. Your diligence in gathering sweets is an inspiration to all.",
            "The Poopocalypse is temporarily subdued! Your score shines like a thousand suns. Thank you for your service to the sweet cause."
        ],
        low: [
            "Pitiful! That score is as weak as your defenses. Did you even try to collect any sweets, mortal?",
            "Hahaha! The Nulli Clan is thriving on your incompetence. Come back when you've learned to dodge something other than your responsibilities!",
            "A tragic and pathetic attempt. That meager score barely registers on our chaos meter. Next!",
            "Jehannum is amused! Such a small total means more treats for our side. Enjoy the taste of failure, weakling!",
            "Did you mistake this for a 'poop collector' game? Your score suggests confusion. You are a true embarrassment!",
            "This isn't even worth a taunt. Your score is a joke. Go practice in the nursery, little one.",
            "Your sweet-gathering skills are a blight on the earth. Perhaps you should stick to something simpler, like breathing.",
            "I was hoping for a challenge, and you delivered *this*? Your score is a stain on the leaderboard.",
            "Look at that low number! Did you rage quit or did the Nulli's gifts simply overwhelm your tiny mind?",
            "You are a disappointment to both clans. That score is a monument to your lack of effort. Don't bother returning."
        ]
    };
    
    // --- DOM Elements & Constants ---
    const launcherContainer = document.getElementById('launcherContainer');
    const gameContainer = document.getElementById('gameContainer');
    const launchButton = document.getElementById('launchButton');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const messageBox = document.getElementById('messageBox');
    const highScoresBody = document.getElementById('highScoresBody');
    const buttonArea = document.getElementById('buttonArea'); 

    const CANVAS_WIDTH = 280;
    const CANVAS_HEIGHT = 280;
    const MAX_LIVES = 5; 
    
    const ANGEL_INTERVAL = 60000;
    const ANGEL_SHOW_DURATION = 1000;
    const WITCH_MIN_INTERVAL = 20000;
    const WITCH_MAX_INTERVAL = 40000;
    const WITCH_SHOW_DURATION = 700;
    const HEROINE_MIN_INTERVAL = 15000;
    const HEROINE_MAX_INTERVAL = 30000;
    const HEROINE_SHOW_DURATION = 500;

    let gameLoopId;
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let playerMoveToX = CANVAS_WIDTH / 2;
    let isPointerDown = false; 
    let lastAngelTime = 0; 
    
    let angelVisible = false;
    let angelHiddenTime = 0;
    let witchVisible = false;
    let witchHiddenTime = 0;
    let nextWitchTime = 0;
    let heroineVisible = false;
    let heroineHiddenTime = 0;
    let nextHeroineTime = 0;
    
    let db, auth, userId;
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

    const player = { 
        x: CANVAS_WIDTH / 2, 
        y: CANVAS_HEIGHT - 30, 
        size: 30, 
        emoji: 'üòã', 
        speed: 9 
    };
    let sweets = [];
    let poops = [];
    let hearts = []; 
    
    let audioContext = null;
    let currentSoundNode = null;

    const sweetEmojis = ['üç¨', 'üç≠', 'üç©', 'üç´', 'üç¶'];
    const poopEmoji = 'üí©';
    const devilEmoji = 'üòà';
    const angelEmoji = 'üòá'; 
    const heartEmoji = 'üíñ'; 
    const witchEmoji = 'üßô‚Äç‚ôÄÔ∏è'; 
    const heroineEmoji = 'üßù‚Äç‚ôÄÔ∏è'; 
    
    let sweetDropSpeed = 1.4; 
    let poopDropSpeed = 2.4;  
    let heartDropSpeed = 0.9; 
    let sweetSpawnRate = 1600; 
    let poopSpawnRate = 1100;
    let lastSweetTime = 0;
    let lastPoopTime = 0;
    let lastTime = 0;
    
    let lastPoopSpeedIncreaseScore = 0; 

    // --- Sound Logic ---
    function playTone(freq, duration = 0.1, type = 'square', volume = 0.5) {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (currentSoundNode) {
             try { currentSoundNode.stop(); currentSoundNode.disconnect(); } catch(e) {}
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration);
        currentSoundNode = oscillator; 
    }

    function stopAllSounds() {
        if (currentSoundNode) {
            try { currentSoundNode.stop(); currentSoundNode.disconnect(); } catch(e) {}
            currentSoundNode = null;
        }
    }

    function playCollectSweetSound() { playTone(880, 0.05, 'sine', 0.4); }
    function playCollectHeartSound() { playTone(1200, 0.1, 'sine', 0.6); }
    function playHitSound() { playTone(110, 0.4, 'square', 0.8); }
    function playGameOverSound() { playTone(50, 1.5, 'triangle', 0.9); }
    function playStartSound() { playTone(440, 0.05, 'sine'); playTone(660, 0.1, 'sine'); }
    function playSpecialClearSound() { playTone(1500, 0.05, 'sine', 0.3); } 
    function playLaunchSound() { playTone(1046.5, 0.1, 'square', 0.6); } 
    
    // --- Dialogue Generation ---
    function getRandomDialogue(isHigh) {
        if (isHigh) {
            const index = Math.floor(Math.random() * PRE_WRITTEN_DIALOGUE.high.length);
            return {
                text: PRE_WRITTEN_DIALOGUE.high[index],
                characterName: 'Mandala',
                emoji: 'üòá',
                clanName: 'FA Clan'
            };
        } else {
            const index = Math.floor(Math.random() * PRE_WRITTEN_DIALOGUE.low.length);
            return {
                text: PRE_WRITTEN_DIALOGUE.low[index],
                characterName: 'Jehannum',
                emoji: 'üòà',
                clanName: 'Nulli Clan'
            };
        }
    }

    async function generateThematicDialogue(finalScore) {
        const clanLabel = document.getElementById('clanLabel');
        const llmResponseContainer = document.getElementById('llmResponseContainer'); 
        const llmResponseText = document.getElementById('llmResponseText');
        const geminiButton = document.getElementById('geminiButton'); 
        
        llmResponseContainer.classList.add('hidden');
        geminiButton.disabled = true;
        llmResponseText.innerHTML = '<div class="loading-spinner"></div> Summoning final word...';
        
        await new Promise(resolve => setTimeout(resolve, 800)); 

        const isHighScore = finalScore >= 300; // Threshold for high/low response
        
        try {
            const result = getRandomDialogue(isHighScore);
            
            const { text, characterName, emoji, clanName } = result;

            llmResponseText.innerHTML = `**${characterName} ${emoji}:** ${text.trim()}`;
            llmResponseContainer.classList.remove('hidden');
            clanLabel.textContent = `Final Word from the ${clanName}:`;

        } catch (error) {
            console.error("Dialogue generation failed:", error);
            llmResponseText.innerHTML = `**Error:** The message scrolls off the screen! Try again.`;
            llmResponseContainer.classList.remove('hidden');

        } finally {
            geminiButton.disabled = false;
        }
    }
    
    // --- Firebase & Firestore Setup ---

    function getHighScoresCollectionRef() {
        // Path for public/shared data: /artifacts/{appId}/public/data/highscores
        return collection(db, `artifacts/${appId}/public/data/highscores`);
    }

    async function setupFirebase() {
        try {
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            
            auth = getAuth(app);
            
            await setPersistence(auth, browserSessionPersistence);
            
            if (typeof __initial_auth_token !== 'undefined') {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
            
            userId = auth.currentUser?.uid || 'guest-' + crypto.randomUUID();
        } catch (error) {
            console.error("Error setting up Firebase:", error);
        }
    }

    async function saveHighScore(name, score) {
        if (!db || score <= 0) {
            console.error("Firestore not initialized or score too low.");
            return;
        }

        try {
            // This is where the permanent, public score is saved
            await addDoc(getHighScoresCollectionRef(), {
                name: name.substring(0, 20) || "Anonymous", 
                score: score,
                timestamp: serverTimestamp(),
                uid: userId
            });
        } catch (e) {
            console.error("Error adding document: ", e);
            throw e; 
        }
    }

    function loadHighScores() {
        if (!db) return;

        // Query to listen for all scores
        const q = query(getHighScoresCollectionRef(), where("score", ">", 0)); 
        
        // onSnapshot listens for real-time changes to the leaderboard
        onSnapshot(q, (querySnapshot) => {
            const scores = [];
            querySnapshot.forEach((doc) => {
                scores.push(doc.data());
            });
            
            // Client-side sort is REQUIRED since orderBy() is avoided
            scores.sort((a, b) => b.score - a.score);
            
            renderHighScores(scores.slice(0, 10));
        }, (error) => {
            console.error("Error listening to high scores:", error);
            highScoresBody.innerHTML = '<tr><td colspan="3" class="text-center py-2 text-red-500">Failed to load scores.</td></tr>';
        });
    }

    function renderHighScores(scores) {
        highScoresBody.innerHTML = '';
        
        if (scores.length === 0) {
            highScoresBody.innerHTML = '<tr><td colspan="3" class="text-center py-2 text-gray-500">No high scores yet!</td></tr>';
            return;
        }
        
        scores.forEach((data, index) => {
            const row = highScoresBody.insertRow();
            row.className = index < 3 ? 'bg-yellow-800/50 font-bold' : 'hover:bg-purple-900/50';
            
            const rankCell = row.insertCell();
            rankCell.textContent = index + 1;
            rankCell.className = 'py-1 px-3 text-center';
            
            const nameCell = row.insertCell();
            nameCell.textContent = data.name;
            nameCell.className = 'py-1 px-3 text-left';
            
            const scoreCell = row.insertCell();
            scoreCell.textContent = data.score;
            scoreCell.className = 'py-1 px-3 text-right';
        });
    }

    // --- Game Logic ---
    const CHAR_POSITIONS = {
        ANGEL: CANVAS_WIDTH / 2 - 80,
        HEROINE: CANVAS_WIDTH / 2 - 40,
        DEVIL: CANVAS_WIDTH / 2,
        WITCH: CANVAS_WIDTH / 2 + 40
    };
    
    function drawEmoji(emoji, x, y, size) {
        ctx.font = `${size}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, x, y);
    }
    function drawDevil() { drawEmoji(devilEmoji, CHAR_POSITIONS.DEVIL, 20, 30); }
    function drawAngel() { if (angelVisible) { drawEmoji(angelEmoji, CHAR_POSITIONS.ANGEL, 20, 30); } }
    function drawWitch() { if (witchVisible) { drawEmoji(witchEmoji, CHAR_POSITIONS.WITCH, 20, 30); } }
    function drawHeroine() { if (heroineVisible) { drawEmoji(heroineEmoji, CHAR_POSITIONS.HEROINE, 20, 30); } }

    function calculateNextWitchTime() {
        const randomInterval = WITCH_MIN_INTERVAL + Math.random() * (WITCH_MAX_INTERVAL - WITCH_MIN_INTERVAL);
        return performance.now() + randomInterval;
    }
    
    function calculateNextHeroineTime() {
        const randomInterval = HEROINE_MIN_INTERVAL + Math.random() * (HEROINE_MAX_INTERVAL - HEROINE_MIN_INTERVAL);
        return performance.now() + randomInterval;
    }
    
    function triggerWitchEffect(currentTime) {
        if (!gameRunning) return;
        sweets = []; 
        playSpecialClearSound();
        witchVisible = true;
        witchHiddenTime = currentTime + WITCH_SHOW_DURATION; 
        nextWitchTime = calculateNextWitchTime();
    }
    
    function triggerHeroineEffect(currentTime) {
        if (!gameRunning) return;
        poops = []; 
        playSpecialClearSound();
        heroineVisible = true;
        heroineHiddenTime = currentTime + HEROINE_SHOW_DURATION; 
        nextHeroineTime = calculateNextHeroineTime();
    }


    function spawnSweet() {
        const x = Math.random() * (CANVAS_WIDTH - 30) + 15;
        const emoji = sweetEmojis[Math.floor(Math.random() * sweetEmojis.length)];
        sweets.push({ x: x, y: 0, size: 18, emoji: emoji, speed: sweetDropSpeed }); 
    }

    function spawnPoop() {
        const x = Math.random() * (CANVAS_WIDTH - 30) + 15;
        poops.push({ x: x, y: 0, size: 18, emoji: poopEmoji, speed: poopDropSpeed }); 
    }
    
    function spawnHeart(currentTime) {
        hearts.push({ 
            x: CHAR_POSITIONS.ANGEL, 
            y: 40, 
            size: 18, 
            emoji: heartEmoji, 
            speed: heartDropSpeed 
        });
        angelVisible = true;
        angelHiddenTime = currentTime + ANGEL_SHOW_DURATION;
    }

    function updateObjects(deltaTime) {
        const factor = deltaTime / 16; 

        sweets = sweets.filter(sweet => {
            sweet.y += sweet.speed * factor;
            return sweet.y < CANVAS_HEIGHT + sweet.size;
        });

        poops = poops.filter(poop => {
            poop.y += poop.speed * factor;
            return poop.y < CANVAS_HEIGHT + poop.size;
        });
        
        hearts = hearts.filter(heart => {
            heart.y += heart.speed * factor;
            return heart.y < CANVAS_HEIGHT + heart.size;
        });
    }

    function checkCollisions() {
        const pRect = { x: player.x - player.size / 2, y: player.y - player.size / 2, width: player.size, height: player.size };

        const isColliding = (r1, r2) => {
            return r1.x < r2.x + r2.width &&
                   r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height &&
                   r1.y + r2.height > r2.y;
        };

        sweets = sweets.filter(sweet => {
            const sRect = { x: sweet.x - sweet.size / 2, y: sweet.y - sweet.size / 2, width: sweet.size, height: sweet.size };
            if (isColliding(pRect, sRect)) {
                score += 10;
                playCollectSweetSound();
                return false;
            }
            return true;
        });

        poops = poops.filter(poop => {
            const rRect = { x: poop.x - poop.size / 2, y: poop.y - poop.size / 2, width: poop.size, height: poop.size };
            if (isColliding(pRect, rRect)) {
                lives--;
                updateHUD();
                playHitSound();
                if (lives <= 0) { endGame(); }
                return false;
            }
            return true;
        });
        
        hearts = hearts.filter(heart => {
            const hRect = { x: heart.x - heart.size / 2, y: heart.y - heart.size / 2, width: heart.size, height: heart.size };
            if (isColliding(pRect, hRect)) {
                if (lives < MAX_LIVES) {
                    lives++;
                    updateHUD();
                    playCollectHeartSound();
                }
                return false;
            }
            return true;
        });
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawDevil();
        drawAngel(); 
        drawWitch(); 
        drawHeroine(); 
        
        ctx.shadowColor = '#a855f7'; 
        ctx.shadowBlur = 12;
        drawEmoji(player.emoji, player.x, player.y, player.size);
        ctx.shadowBlur = 0; 
        
        sweets.forEach(sweet => { drawEmoji(sweet.emoji, sweet.x, sweet.y, sweet.size); });
        poops.forEach(poop => { drawEmoji(poop.emoji, poop.x, poop.y, poop.size); });
        hearts.forEach(heart => { drawEmoji(heart.emoji, heart.x, heart.y, heart.size); });
    }
    
    function increaseDifficulty() {
        const poopSpeedIncrement = 0.02; 
        const poopSpeedInterval = 10;
        
        if (score >= lastPoopSpeedIncreaseScore + poopSpeedInterval) {
            poopDropSpeed += poopSpeedIncrement;
            lastPoopSpeedIncreaseScore = Math.floor(score / poopSpeedInterval) * poopSpeedInterval;
        }
        
        if (score > 0 && score % 50 === 0 && score % 10 !== 0) {
            sweetDropSpeed += 0.1; 
            player.speed += 0.05;
            sweetSpawnRate = Math.max(650, sweetSpawnRate - 10);
            poopSpawnRate = Math.max(450, poopSpawnRate - 10);
        }
    }

    function getPointerX(event) {
        if (event.touches && event.touches.length > 0) {
            return event.touches[0].clientX;
        }
        if (event.clientX !== undefined) {
            return event.clientX;
        }
        return null; 
    }

    function setPlayerTarget(event) {
        event.preventDefault(); 
        if (!gameRunning) return; 

        isPointerDown = true; 

        const clientX = getPointerX(event);
        if (clientX === null) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        
        // Calculate the target X position in canvas coordinates
        let newX = (clientX - rect.left) * scaleX; 
        
        // Clamp the target position to keep the player on screen
        playerMoveToX = Math.max(player.size / 2, Math.min(CANVAS_WIDTH - player.size / 2, newX));
    }

    function releasePointer(event) {
        if (event.type === 'pointerup' || event.type === 'pointerleave' || event.type === 'touchend' || event.type === 'touchcancel') {
            isPointerDown = false;
        }
    }
    
    function setupInputListeners() {
        // Use generic 'pointer' events for unified mouse/touch input
        canvas.addEventListener('pointerdown', setPlayerTarget);
        canvas.addEventListener('pointermove', setPlayerTarget);
        canvas.addEventListener('pointerup', releasePointer);
        canvas.addEventListener('pointerleave', releasePointer); 
        
        // Also add dedicated touch handlers for robustness on some devices
        canvas.addEventListener('touchstart', setPlayerTarget);
        canvas.addEventListener('touchmove', setPlayerTarget);
        canvas.addEventListener('touchend', releasePointer);
        canvas.addEventListener('touchcancel', releasePointer);
        
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    }
    
    function movePlayer(deltaTime) {
        if (!isPointerDown) {
            return;
        }

        const factor = deltaTime / 16;
        const dx = playerMoveToX - player.x;
        const distance = Math.abs(dx);
        const step = player.speed * factor;

        if (distance > step) {
            player.x += Math.sign(dx) * step;
        } else {
            player.x = playerMoveToX;
        }
    }

    function updateHUD() {
        scoreDisplay.textContent = score;
        livesDisplay.innerHTML = '‚ù§Ô∏è '.repeat(Math.min(lives, MAX_LIVES));
        if (lives <= 0) { livesDisplay.innerHTML = 'üíî'; }
    }

    function showMessage(title, text, buttons) {
        document.getElementById('messageTitle').textContent = title;
        const llmResponseContainer = document.getElementById('llmResponseContainer'); 
        llmResponseContainer.classList.add('hidden');
        document.getElementById('llmResponseText').textContent = '';
        
        const formattedText = text
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\n/g, '<br>'); 
            
        document.getElementById('messageText').innerHTML = formattedText;
        
        buttonArea.innerHTML = '';
        
        buttons.forEach(btn => {
            const button = document.createElement('button');
            button.id = btn.id;
            button.className = `button w-full md:w-auto ${btn.className || ''}`;
            button.textContent = btn.text;
            button.onclick = btn.action;
            button.disabled = false;
            
            buttonArea.appendChild(button);
        });
        
        messageBox.style.display = 'flex';
    }

    function hideMessage() {
        messageBox.style.display = 'none';
        document.getElementById('llmResponseContainer').classList.add('hidden');
    }

    // --- Game Flow Control ---

    function gameLoop(currentTime) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;
        
        // Spawning
        if (currentTime - lastSweetTime > sweetSpawnRate) {
            spawnSweet();
            lastSweetTime = currentTime;
        }
        if (currentTime - lastPoopTime > poopSpawnRate) {
            spawnPoop();
            lastPoopTime = currentTime;
        }
        
        // Character Timers
        if (hearts.length === 0 && currentTime - lastAngelTime > ANGEL_INTERVAL) {
            spawnHeart(currentTime); 
            lastAngelTime = currentTime;
        }
        
        // Character Hiding
        if (angelVisible && currentTime > angelHiddenTime) { angelVisible = false; }
        if (witchVisible && currentTime > witchHiddenTime) { witchVisible = false; }
        if (heroineVisible && currentTime > heroineHiddenTime) { heroineVisible = false; }

        // Character Triggering
        if (!witchVisible && currentTime >= nextWitchTime) { triggerWitchEffect(currentTime); }
        if (!heroineVisible && currentTime >= nextHeroineTime) { triggerHeroineEffect(currentTime); }

        movePlayer(deltaTime);
        updateObjects(deltaTime);
        checkCollisions();
        increaseDifficulty();
        updateHUD(); 

        gameLoopId = requestAnimationFrame(gameLoop);
        draw();
    }
    
    function startGame() {
        if (gameRunning) return;
        
        resetGame();
        playStartSound();
        gameRunning = true;
        
        lastTime = performance.now();
        lastAngelTime = lastTime; 
        nextWitchTime = calculateNextWitchTime(); 
        nextHeroineTime = calculateNextHeroineTime();
        
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        cancelAnimationFrame(gameLoopId);
        stopAllSounds();
        score = 0;
        lives = 3;
        sweets = [];
        poops = [];
        hearts = []; 
        lastAngelTime = performance.now(); 
        angelVisible = false;
        witchVisible = false;
        nextWitchTime = calculateNextWitchTime();
        heroineVisible = false;
        nextHeroineTime = calculateNextHeroineTime();

        // Reset difficulty
        sweetDropSpeed = 1.4;
        poopDropSpeed = 2.4;
        sweetSpawnRate = 1600;
        poopSpawnRate = 1100;
        player.speed = 9;
        player.x = CANVAS_WIDTH / 2;
        playerMoveToX = CANVAS_WIDTH / 2;
        isPointerDown = false;
        lastPoopSpeedIncreaseScore = 0;
        
        updateHUD();
        draw(); 
        hideMessage();
    }

    async function submitScoreAndRestart(finalScore) {
        const input = document.getElementById('playerNameInput');
        const name = input ? input.value.trim() : "Anonymous";
        
        const button = document.getElementById('submitButton');
        if (button) button.disabled = true; 
        
        try {
            await saveHighScore(name, finalScore); // Saves the score to the permanent leaderboard
        } catch(err) {
            console.error("Submission failed, proceeding with restart:", err);
        } finally {
            if (button) button.disabled = false;
            startGame();
        }
    }

    function endGame() {
        gameRunning = false;
        cancelAnimationFrame(gameLoopId);
        stopAllSounds();
        playGameOverSound();
        
        const finalScore = score;
        
        const messageContent = `The üòà got you! Your **total score** is **${finalScore}**.<br><br>

Enter your name to record your high score on the permanent, competitive leaderboard:
<div class="mt-3">
    <input type="text" id="playerNameInput" placeholder="Your Name (max 20 chars)" maxlength="20" class="w-full p-2 rounded text-black mb-2 text-base focus:ring-2 focus:ring-yellow-500 focus:outline-none" />
</div>`;

        const buttons = [
            { 
                id: 'geminiButton', 
                text: '‚ú® Get Final Word', 
                action: () => generateThematicDialogue(finalScore), 
                className: 'button-llm' 
            },
            { 
                id: 'submitButton', 
                text: 'Submit Score & Play Again', 
                action: () => submitScoreAndRestart(finalScore), 
                className: 'button-submit' 
            }
        ];

        showMessage("GAME OVER!", messageContent, buttons);
        setTimeout(() => { document.getElementById('playerNameInput')?.focus(); }, 100);
    }
    
    function showIntroMessage() {
        const introText = `Welcome to **üòà Poopocalypse: Nulli Rising üßô**! You control üòã to collect treats (üç¨, üç≠) and score points! Avoid the repulsive üí© from evil **Jehannum** (üòà). As you collect more sweets, the poops will fall faster!

Look for the üòá angel **Mandala** (drops üíñ for +1 life) and the üßù‚Äç‚ôÄÔ∏è heroine **Zey** (destroys all üí©!). Be wary of the üßô‚Äç‚ôÄÔ∏è witch **Jackyna** (clears all treats!).

Use your finger/cursor to move üòã and survive the onslaught! Get the highest score on the permanent leaderboard below!`;

        const buttons = [
            { id: 'startButton', text: "Let's Go!", action: startGame, className: 'button-submit' }
        ];

        showMessage(
            "üòà Poopocalypse: Nulli Rising üßô",
            introText,
            buttons
        );
    }

    // --- Initialization & Launcher ---

    function showGame() {
        launcherContainer.style.display = 'none';
        gameContainer.style.display = 'flex';
        showIntroMessage();
    }
    
    function setupLauncher() {
        launchButton.addEventListener('click', () => {
            playLaunchSound();
            setTimeout(showGame, 100);
        });
    }

    async function init() {
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        
        setupLauncher(); 
        setupInputListeners(); 
        
        await setupFirebase();
        
        if (db) {
            loadHighScores(); // Sets up the real-time listener for the permanent leaderboard
        }
        
        resetGame(); // Initial clean slate
    }

    window.onload = init;
</script>
</body>
</html>

