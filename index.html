<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>😈 Poopocalypse: Nulli Rising 🧙</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Pixelify+Sans:wght@700&family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* --- General Variables & Body --- */
        :root {
            --dark-bg: #1a1a2e; /* Dark Navy/Purple */
            --card-bg: #2d2d44; /* Darker Card Background */
            --neon-green: #00f800;
            --gold-title: #ffcc00;
            --text-color: #ffffff;
        }

        /* --- FONT CHANGE APPLIED HERE --- */
        body {
            background-color: var(--dark-bg);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive; /* CHANGED to Press Start 2P */
            font-size: 12px; /* Base size adjustment for pixel font legibility */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            margin: 0;
            transition: background-color 0.5s;
        }

        /* --- Loading Screen Styles (NEW) --- */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--dark-bg);
            z-index: 200; /* Above everything */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--neon-green);
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            transition: opacity 0.5s ease-out;
            opacity: 1; /* Start opaque */
        }
        .loading-title {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            color: var(--gold-title);
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
        }
        #loadingText {
            font-size: 0.8rem;
            margin-top: 1rem;
            color: #ffffff;
        }
        #loadingBarContainer {
            width: 80%;
            max-width: 300px;
            height: 16px;
            border: 2px solid var(--neon-green);
            border-radius: 8px;
            margin-top: 1rem;
            overflow: hidden;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }
        #loadingBar {
            height: 100%;
            width: 0%;
            background-color: var(--neon-green);
            transition: width 0.1s linear;
        }

        /* --- Launcher Card Styles --- */
        /* Make sure it's hidden initially */
        #launcherContainer {
            background-color: var(--card-bg);
            border: 4px solid var(--neon-green);
            box-shadow: 0 10px 30px rgba(0, 255, 0, 0.4);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            text-align: left; 
        }
        .main-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            color: var(--neon-green);
            text-shadow: 2px 2px 0 #000000;
            margin-bottom: 1.5rem;
            margin-left: auto;
            margin-right: auto;
            max-width: fit-content;
        }
        .description {
            font-size: 0.8rem;
            line-height: 1.8;
            margin-bottom: 2.5rem;
            color: #c0c0c0;
            text-align: left;
        }

        /* --- New Title Styles for Introduction --- */
        .fa-title {
            color: #ffcc00; /* Yellow/Gold */
            font-weight: 700;
            font-size: 0.85rem; 
            display: block; 
            margin: 0.75rem 0 0.5rem 0;
            text-shadow: 1px 1px 0 #000;
            text-align: left; 
        }
        .nulli-title {
            color: #ef4444; /* Red */
            font-weight: 700;
            font-size: 0.85rem;
            display: block;
            margin: 0.75rem 0 0.5rem 0;
            text-shadow: 1px 1px 0 #000;
            text-align: left; 
        }

        .launch-button {
            padding: 1rem 2.5rem;
            font-size: 1.1rem;
            font-weight: 700;
            color: black;
            background: linear-gradient(145deg, var(--neon-green), #18a558);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 4px #006400;
            user-select: none;
            text-transform: uppercase;
            font-family: 'Press Start 2P', cursive; 
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        .launch-button:hover {
            background: linear-gradient(145deg, #39ff14, #24d673);
            transform: translateY(-2px);
            box-shadow: 0 6px #006400;
        }
        .launch-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px #006400;
        }

        /* Control Selector Styles */
        .control-selector {
            margin: 1.5rem 0;
            padding: 1rem;
            background-color: #4a148c; /* Deep Violet */
            border: 2px solid #ffcc00;
            border-radius: 10px;
            text-align: center;
        }
        .control-selector label {
            display: block;
            font-size: 0.8rem;
            font-weight: 700;
            cursor: pointer;
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 6px;
            transition: background-color 0.1s;
        }
        .control-selector input[type="radio"]:checked + label {
            background-color: #00f800;
            color: black;
            box-shadow: 0 0 10px #00f800;
        }
        .control-selector input[type="radio"] {
            display: none;
        }


        /* --- Game Container Styles (starts hidden) --- */
        #gameContainer {
            display: none; /* Initially hidden */
            background-color: #2d2d44;
            border: 6px solid #00f800;
            box-shadow: 0 8px 20px rgba(0, 255, 0, 0.4);
            border-radius: 18px;
            padding: 0;
            /* Allow game container to grow responsively */
            max-width: 500px; 
            width: 100%;
            flex-direction: column;
            align-items: center;
            font-family: 'Press Start 2P', cursive; 
            overflow: hidden;
        }
        .game-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: #00f800;
            text-shadow: 3px 3px 0 #000000;
            line-height: 1.4;
            padding: 0.5rem;
            /* FIX APPLIED HERE: Centering the text */
            text-align: center;
        }

        /* --- CONSOLIDATED TOP HUD STYLES --- */
        #consolidatedHud {
            background-color: #111827; /* Dark background for HUD */
            padding: 0.4rem 0.6rem;
            border-bottom: 2px solid #ffcc00; /* Gold divider */
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0.1rem 0;
            font-size: 0.7rem; 
            font-weight: 700;
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
        }

        #hudPanel {
            padding: 0.4rem 0;
            gap: 0.5rem;
        }
        /* End HUD Styles */

        canvas {
            display: block;
            background-color: #4a148c; /* Deep Violet Canvas */
            border: 3px solid #ffeb3b; /* Yellow/Gold Inner Border */
            border-radius: 6px;
            margin: 0.5rem auto; /* Center with margin */
            touch-action: none;
            /* CRITICAL: Ensure canvas scales responsively */
            width: calc(100% - 1rem); /* 100% minus some margin for inner border */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 1 / 1; /* Force square aspect ratio */
        }

        /* --- NEW CONTROL BUTTON STYLES --- */
        #controls {
            /* This is dynamically hidden/shown by JS based on controlMode */
            display: none; 
            justify-content: center; /* Center the buttons horizontally */
            width: 100%;
            padding: 15px 0;
            margin-top: 5px; /* Gap between canvas and buttons */
        }

        #controls button {
            padding: 10px 20px; 
            font-size: 0.8rem; 
            font-weight: 700;
            color: black;
            background: linear-gradient(145deg, #fceb9c, #ffcc00);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: 0 3px #cc9900;
            user-select: none;
            text-transform: uppercase;
            font-family: 'Press Start 2P', cursive;
            margin: 0 10px; /* Space between buttons */
            min-width: 120px;
        }

        #controls button:active {
            transform: translateY(1px);
            box-shadow: 0 2px #cc9900;
        }
        /* --- END NEW CONTROL BUTTON STYLES --- */

        .button {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            font-weight: 700;
            color: black;
            background: linear-gradient(145deg, #fceb9c, #ffcc00);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: 0 3px #cc9900;
            user-select: none;
        }
        /* Styles for Game Over/Message Box */
        .button-llm {
            background: linear-gradient(145deg, #00f800, #18a558);
            box-shadow: 0 3px #006400;
            color: black;
        }
        .button-submit {
            background: linear-gradient(145deg, #fceb9c, #ffcc00);
            box-shadow: 0 3px #cc9900;
            color: black;
        }


        #messageBox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            font-family: 'Press Start 2P', cursive; 
            display: none;
        }
        #messageBox > div {
            max-width: 90%;
            padding: 15px;
            background-color: #1a1a2e;
            border: 2px solid #00f800;
            border-radius: 12px;
            width: 90%;
            max-width: 380px;
        }
        #messageBox h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem; 
            margin-bottom: 0.5rem;
            color: #ffcc00;
        }
        .leaderboard-card {
            background-color: #1a1a2e;
            border: 2px solid #00f800;
            border-radius: 10px;
            padding: 0.4rem;
            margin: 0.5rem auto; 
            width: calc(100% - 1rem);
        }
        #highScoresTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        #highScoresTable th {
            background-color: #4a148c;
            color: #ffcc00;
            padding: 0.3rem;
            text-align: left;
            font-family: 'Press Start 2P', cursive;
        }
        #highScoresTable td {
            border-bottom: 1px solid #4a148c;
            color: #c0c0c0;
            padding: 0.3rem;
            font-size: 0.7rem; 
        }

        /* This style specifically targets the intro message instruction text to use a readable font */
        .intro-instruction {
            font-family: 'Press Start 2P', cursive !important; 
            font-weight: 700;
            color: #00f800;
            font-size: 0.9rem; 
            display: block;
            margin-top: 0.75rem;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            .main-title {
                font-size: 1.2rem;
            }
            #launcherContainer {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>

<!-- NEW: Loading Screen - Displays the game title and a progress bar -->
<div id="loadingScreen">
    <div class="loading-title">
        <span class="text-3xl animate-pulse">😈</span> POOPOCALYPSE: NULLI RISING <span class="text-3xl animate-pulse">🧙</span>
    </div>
    <div id="loadingText" class="text-base">INITIALIZING ASSETS... 0%</div>
    <div id="loadingBarContainer">
        <div id="loadingBar"></div>
    </div>
</div>
<!-- END NEW: Loading Screen -->


<div id="launcherContainer" class="flex flex-col hidden">
    <div class="main-title">😈 POOPOCALYPSE: NULLI RISING 🧙</div>

    <p class="description">
        Hark! The Poopocalypse is Upon Us!<br>
        The land is under siege by the dreadful Nulli Clan. Their merciless leader, <b>Jehannum (😈)</b>, throws vile <b>Poop (💩)</b> and ground-shattering <b>Mini-Bombs (💥)</b>, which create temporary <b>No-Go Zones</b> upon impact, and transforms into the terrifying <b>Nulli Boss (👹)</b> every 500 points!
        <br><br>
        Your Mission: Survival and Sweets!
        <ul>
            <li><b>Collect:</b> Gather vital Sweets (🍬,🍭,🍩) to earn points and sustain your existence.</li>
            <li><b>Avoid:</b> Steer clear of the vile Poop (💩) and Mini-Bombs (💥) or their resulting <b>No-Go Zones</b>. Getting hit means losing a life and being slowed!</li>
        </ul>
        <br>
        <span class="fa-title">THE FA HEROES</span><br>
        These celestial allies fight the filth and provide aid:
        <ul>
            <li>
                <b>Mandala (😇):</b> The Angel drops critical Power-Ups to aid your collection.
                <ul class="list-disc list-inside ml-4 mt-1">
                    <li><b>🛡️ Shield:</b> Grants temporary immunity to the next harmful collision.</li>
                    <li><b>🧲 Magnet:</b> Pulls all nearby Sweets towards your collector for easy grabbing.</li>
                    <li><b>💖 Heart:</b> Restores one life (up to a maximum of five).</li>
                </ul>
            </li>
            <li><b>Zey (🧝‍♀️):</b> The Heroine uses her magic to slow all Poop and Mini-Bombs for 5 seconds!</li>
        </ul>
        <br>
        <span class="nulli-title">THE NULLI VILLAINS</span><br>
        These dark allies of Jehannum bring chaos to the field:
        <ul>
            <li><b>Jackyna (🧙‍♀️):</b> The Witch uses dark magic to slow all Sweets for 5 seconds, making them harder to collect!</li>
            <li><b>Jehannum (😈):</b> The Source of the filth! Throws Poop and Bombs.</li>
        </ul>
        <br><br> 
    </p>

    <!-- NEW CONTROL SELECTION UI -->
    <div class="control-selector">
        <span class="fa-title" style="margin-top: 0; color: #ffcc00;">SELECT CONTROL MODE</span>

        <input type="radio" id="control-buttons" name="control-mode" value="buttons" checked>
        <label for="control-buttons">
            ➡️ BUTTONS: Use the Left/Right buttons below the canvas.
        </label>

        <input type="radio" id="control-touch" name="control-mode" value="touch">
        <label for="control-touch">
            👆 TOUCH/DRAG: Drag your finger/mouse across the screen to move.
        </label>
    </div>
    <!-- END NEW CONTROL SELECTION UI -->

    <button id="launchButton" class="launch-button">
        Launch Game Now!
    </button>
</div>


<div id="gameContainer" class="game-container">
    <h1 class="game-title">😈 POOPOCALYPSE: NULLI RISING 🧙</h1>

    <!-- Consolidated Top HUD: Score, Lives, and Cooldowns -->
    <div id="consolidatedHud" class="w-full flex flex-col">
        <!-- Score and Lives -->
        <div class="info-bar">
            <span>Score: <span id="scoreDisplay">0</span></span>
            <!-- Lives display uses flex to manage heart spacing -->
            <span>Lives: <span id="livesDisplay" class="flex items-center gap-0.5"></span></span>
        </div>

        <!-- Cooldowns (Mandala/Jackyna/Zey Bars) -->
        <div id="hudPanel" class="w-full flex justify-around text-xs font-bold">
            <!-- Mandala Bar (Angel Power-up Cooldown) - FIRST (Mandala) -->
            <div class="flex-1 bg-gray-700 rounded-full overflow-hidden relative h-4">
                <div class="absolute inset-0 text-center text-white z-10 text-[8px] sm:text-[10px]" id="mandalaLabel">😇 MANDALA</div>
                <div id="mandalaBar" class="h-4 bg-purple-500 transition-all duration-100"></div>
            </div>

            <!-- Zey Bar (Poop Clear Cooldown) - SECOND (Zey) -->
            <div class="flex-1 bg-gray-700 rounded-full overflow-hidden relative h-4">
                <div class="absolute inset-0 text-center text-white z-10 text-[8px] sm:text-[10px]" id="zeyLabel">🧝‍♀️ ZEY</div>
                <div id="zeyBar" class="h-4 bg-blue-500 transition-all duration-100"></div>
            </div>

            <!-- Jackyna Bar (Sweet Clear Cooldown) - THIRD (Jackyna) -->
            <div class="flex-1 bg-gray-700 rounded-full overflow-hidden relative h-4">
                <div class="absolute inset-0 text-center text-white z-10 text-[8px] sm:text-[10px]" id="jackynaLabel">🧙‍♀️ JACKYNA</div>
                <div id="jackynaBar" class="h-4 bg-red-500 transition-all duration-100"></div>
            </div>
        </div>
    </div>

    <!-- Canvas is set to default 400x400, but CSS makes it responsive -->
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    
    <!-- NEW CONTROL BUTTONS SECTION - HIDDEN BY DEFAULT, SHOWN FOR BUTTON MODE -->
    <div id="controls">
        <button id="move-left" aria-label="Move Left">
            ⬅️ Left
        </button>
        <button id="move-right" aria-label="Move Right">
            Right ➡️
        </button>
    </div>
    <!-- END NEW CONTROL BUTTONS SECTION -->
</div>


<div id="messageBox">
    <div>
        <h2 id="messageTitle"></h2>

        <div id="llmResponseContainer" class="mt-3 hidden">
            <div id="clanLabel" class="text-sm font-bold text-yellow-500 mb-1">Final Word from the Clan:</div>
            <p id="llmResponseText" class="text-xs text-left p-2 rounded bg-purple-900/50 border border-yellow-700"></p>
        </div>

        <p id="messageText" class="mt-3 mb-0"></p>
        
        <!-- NEW LEADERBOARD LOCATION - Hidden by default -->
        <div id="leaderboardDisplay" class="leaderboard-card mt-4 hidden">
            <h2 class="text-base font-bold text-center text-yellow-500 mb-1 font-['Press Start+2P']">🏆 Top Sweet Collectors 🏆</h2>
            <table id="highScoresTable">
                <thead>
                    <tr>
                        <th class="rounded-tl-lg">Rank</th>
                        <th>Name</th>
                        <th class="rounded-tr-lg text-right">Score</th>
                    </tr>
                </thead>
                <tbody id="highScoresBody">
                    <tr><td colspan="3" class="text-center py-2 text-gray-500">Loading...</td></tr>
                </tbody>
            </table>
        </div>
        <!-- END NEW LEADERBOARD LOCATION -->

        <div id="buttonArea" class="flex flex-col md:flex-row justify-center items-center gap-2 mt-4">
        </div>
    </div>
</div>


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, onSnapshot, query, where, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Set Firestore log level to debug for troubleshooting
    setLogLevel('Debug');

    // --- PRE-WRITTEN DIALOGUE ---
    const PRE_WRITTEN_DIALOGUE = {
        high: [
            "Your score is a testament to the divine light! The FA Clan celebrates this monumental sweep of sweetness. Truly a glorious day!",
            "Such grace and dedication! You've soared above the Nulli filth. Keep collecting, for the celestial hoard is ever expanding!",
            "A magnificent feat! You are a beacon of hope against the Poopocalypse. The heavens smile upon your high score of collected treats.",
            "Mandala is impressed! This score is a prayer answered, a perfect harmony of skill and luck. Go forth and shine!",
            "Hark! The Nulli Clan trembles at this total. You have proven that virtue is stronger than vile stench. Excellent work!",
            "Look at those numbers! An ethereal harvest! May your next run bring even greater glory to the FA Clan's cause.",
            "You have achieved true purity of purpose. This high score ensures your name is sung throughout the halls of the heavens!",
            "Divine! The Nulli's attempts were futile against such masterful collection. Keep your spirit bright and your bucket full!",
            "I grant you my blessing for this outstanding result. Your diligence in gathering sweets is an an inspiration to all.",
            "The Poopocalypse is temporarily subdued! Your score shines like a thousand suns. Thank you for your service to the sweet cause."
        ],
        low: [
            "Pitiful! That score is as weak as your defenses. Did you even try to collect any sweets, mortal?",
            "Hahaha! The Nulli Clan is thriving on your incompetence. Come back when you've learned to dodge something other than your responsibilities!",
            "A tragic and pathetic attempt. That meager score barely registers on our chaos meter. Next!",
            "Jehannum is amused! Such a small total means more treats for our side. Enjoy the taste of failure, weakling!",
            "Did you mistake this for a 'poop collector' game? Your score suggests confusion. You are a true embarrassment!",
            "This isn't even worth a taunt. Your score is a joke. Go practice in the nursery, little one.",
            "Your sweet-gathering skills are a blight on the earth. Perhaps you should stick to something simpler, like breathing.",
            "I was hoping for a challenge, and you delivered this? Your score is a stain on the leaderboard.",
            "Look at that low number! Did you rage quit or did the Nulli's gifts simply overwhelm your tiny mind?",
            "You are a disappointment to both clans. That score is a monument to your lack of effort. Don't bother returning."
        ]
    };

    // --- DOM Elements & Constants ---
    const loadingScreen = document.getElementById('loadingScreen');
    const loadingBar = document.getElementById('loadingBar');
    const loadingText = document.getElementById('loadingText');

    const launcherContainer = document.getElementById('launcherContainer');
    const gameContainer = document.getElementById('gameContainer');
    const launchButton = document.getElementById('launchButton');
    const controlsContainer = document.getElementById('controls'); // New ref
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const messageBox = document.getElementById('messageBox');
    const highScoresBody = document.getElementById('highScoresBody');
    const buttonArea = document.getElementById('buttonArea');
    const leaderboardDisplay = document.getElementById('leaderboardDisplay');

    // HUD ELEMENTS
    const mandalaBar = document.getElementById('mandalaBar');
    const jackynaBar = document.getElementById('jackynaBar');
    const zeyBar = document.getElementById('zeyBar');

    // NEW HUD LABELS
    const mandalaLabel = document.getElementById('mandalaLabel');
    const zeyLabel = document.getElementById('zeyLabel');
    const jackynaLabel = document.getElementById('jackynaLabel');


    // Canvas size is now dynamic - using initial size for aspect ratio only
    const INITIAL_CANVAS_HEIGHT = 400; // Used for calculating player Y position
    const MAX_LIVES = 5;

    // Custom Constant for New Feature
    const OBJECT_SLOW_DURATION = 5000; // 5 seconds
    const SLOW_FACTOR = 0.25; // Objects move at 25% of their base speed

    // Character cooldowns
    const ANGEL_INTERVAL = 40000;
    const ANGEL_SHOW_DURATION = 1000;
    const JACKYNA_MIN_INTERVAL = 20000;
    const JACKYNA_MAX_INTERVAL = 40000;
    const JACKYNA_SHOW_DURATION = 700;
    const ZEY_MIN_INTERVAL = 15000;
    const ZEY_MAX_INTERVAL = 30000;
    const ZEY_SHOW_DURATION = 500;

    // Game State
    let gameLoopId;
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let lastTime = 0;
    
    // Movement state variables
    let moveLeft = false;
    let moveRight = false;
    let isPointerDown = false; // New state for touch/drag mode
    
    // NEW: Control Mode State
    let controlMode = 'buttons'; // Default mode

    let angelVisible = false;
    let angelHiddenTime = 0;
    let lastAngelTime = 0;

    let jackynaVisible = false;
    let jackynaHiddenTime = 0;
    let lastJackynaTime = 0;
    let nextJackynaTime = 0;

    let zeyVisible = false;
    let zeyHiddenTime = 0;
    let lastZeyTime = 0;
    let nextZeyTime = 0;

    let db, auth, userId;
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

    // Player and Objects
    const player = {
        x: canvas.width / 2,
        y: INITIAL_CANVAS_HEIGHT - 30, // Y position is fixed relative to bottom
        size: 30,
        emoji: '😋',
        baseSpeed: 5, 
        speed: 5,     
        invulnerable: false 
    };

    let sweets = [];
    let poops = [];
    let powerUps = [];
    let miniBombs = [];
    let noGoZones = []; 
    const BOMB_EXPLOSION_DURATION = 2500; 
    const MINI_BOMB_SCORE_START = 200;
    let lastBombTime = 0;
    const BOMB_SPAWN_INTERVAL = 3500;

    // Status Effects State
    let powerUpActive = null; 
    const POWER_UP_DURATION = 8000; 
    let powerUpEndTime = 0;

    let playerSlowed = false; 
    const PLAYER_SLOW_DURATION = 3000;
    let slowEndTime = 0;

    // Boss State
    let nulliBossActive = false;
    const BOSS_INTERVAL_SCORE = 500;
    const BOSS_DURATION = 10000; 
    let bossEndTime = 0;


    // Object properties
    let sweetDropSpeed = 1.4;
    let poopDropSpeed = 2.4;
    let powerUpDropSpeed = 0.9;
    let sweetSpawnRate = 1600;
    let poopSpawnRate = 1100;
    let lastSweetTime = 0;
    let lastPoopTime = 0;
    let lastPoopSpeedIncreaseScore = 0;

    // Emojis & Positions
    const sweetEmojis = ['🍬', '🍭', '🍩', '🍫', '🍦'];
    const poopEmoji = '💩';
    const devilEmoji = '😈';
    const angelEmoji = '😇';
    const jackynaEmoji = '🧙‍♀️';
    const zeyEmoji = '🧝‍♀️';
    const nulliBossEmoji = '👹';

    const POWER_UP_DROPS = {
        HEART: { emoji: '💖', type: 'heart' },
        SHIELD: { emoji: '🛡️', type: 'shield' },
        MAGNET: { emoji: '🧲', type: 'magnet' }
    };
    const angelDrops = [POWER_UP_DROPS.HEART, POWER_UP_DROPS.SHIELD, POWER_UP_DROPS.MAGNET];
    
    // Function to dynamically calculate character positions based on current canvas width
    function getCharPositions(width) {
        return {
            DEVIL: width / 2,
            ZEY: width / 2 - 60,
            JACKYNA: width / 2 + 60,
            ANGEL: width / 2 - 120
        };
    }

    let audioContext = null;
    let currentSoundNode = null;

    // --- Sound Logic (using Web Audio API directly) ---
    function playTone(freq, duration = 0.1, type = 'square', volume = 0.5) {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (currentSoundNode) {
             try { currentSoundNode.stop(); currentSoundNode.disconnect(); } catch(e) {}
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration);
        currentSoundNode = oscillator;
    }

    function stopAllSounds() {
        if (currentSoundNode) {
            try { currentSoundNode.stop(); currentSoundNode.disconnect(); } catch(e) {}
            currentSoundNode = null;
        }
    }

    function playCollectSweetSound() { playTone(880, 0.05, 'sine', 0.4); }
    function playCollectPowerUpSound() { playTone(1200, 0.1, 'sine', 0.6); }
    function playHitSound() { playTone(110, 0.4, 'square', 0.8); }
    function playGameOverSound() { playTone(50, 1.5, 'triangle', 0.9); }
    function playStartSound() { playTone(440, 0.05, 'sine'); playTone(660, 0.1, 'sine'); }
    function playSpecialClearSound() { playTone(1500, 0.05, 'sine', 0.3); }
    function playLaunchSound() { playTone(1046.5, 0.1, 'square', 0.6); }

    // --- Dialogue Generation ---
    function getRandomDialogue(isHigh) {
        if (isHigh) {
            const index = Math.floor(Math.random() * PRE_WRITTEN_DIALOGUE.high.length);
            return {
                text: PRE_WRITTEN_DIALOGUE.high[index],
                characterName: 'Mandala',
                emoji: '😇',
                clanName: 'FA Clan'
            };
        } else {
            const index = Math.floor(Math.random() * PRE_WRITTEN_DIALOGUE.low.length);
            return {
                text: PRE_WRITTEN_DIALOGUE.low[index],
                characterName: 'Jehannum',
                emoji: '😈',
                clanName: 'Nulli Clan'
            };
        }
    }

    function showFinalWord(finalScore) {
        const clanLabel = document.getElementById('clanLabel');
        const llmResponseContainer = document.getElementById('llmResponseContainer');
        const llmResponseText = document.getElementById('llmResponseText');
        const finalWordButton = document.getElementById('finalWordButton');

        const isVisible = !llmResponseContainer.classList.contains('hidden');

        if (isVisible) {
            llmResponseContainer.classList.add('hidden');
            llmResponseText.innerHTML = '';
            if (finalWordButton) finalWordButton.textContent = '✨ View Final Word';
        } else {
            const isHighScore = finalScore >= 300;

            try {
                const result = getRandomDialogue(isHighScore);
                const { text, characterName, emoji, clanName } = result;

                llmResponseText.innerHTML = `<strong>${characterName} ${emoji}:</strong> ${text.trim()}`;
                llmResponseContainer.classList.remove('hidden');
                clanLabel.textContent = `Final Word from the ${clanName}:`;
                if (finalWordButton) finalWordButton.textContent = 'Hide Final Word';

            } catch (error) {
                console.error("Dialogue generation failed:", error);
                llmResponseText.innerHTML = `**Error:** Internal data error. Try again.`;
                llmResponseContainer.classList.remove('hidden');
            }
        }
    }

    /**
     * Toggles the visibility of the high score leaderboard in the message box.
     * @param {HTMLElement} buttonElement The button that triggered the toggle.
     */
    function toggleLeaderboard(buttonElement) {
        if (leaderboardDisplay.classList.contains('hidden')) {
            leaderboardDisplay.classList.remove('hidden');
            buttonElement.textContent = 'Hide Top Sweet Collectors 🏆';
        } else {
            leaderboardDisplay.classList.add('hidden');
            buttonElement.textContent = 'View Top Sweet Collectors 🏆';
        }
    }


    // --- Firebase & Firestore Setup ---

    function getHighScoresCollectionRef() {
        return collection(db, `artifacts/${appId}/public/data/highscores`);
    }

    async function setupFirebase() {
        try {
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);

            auth = getAuth(app);

            await setPersistence(auth, browserSessionPersistence);

            if (typeof __initial_auth_token !== 'undefined') {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }

            userId = auth.currentUser?.uid || 'guest-' + crypto.randomUUID();
        } catch (error) {
            console.error("Error setting up Firebase:", error);
        }
    }

    async function saveHighScore(name, score) {
        if (!db || score <= 0) {
            console.error("Firestore not initialized or score too low.");
            return;
        }

        try {
            await addDoc(getHighScoresCollectionRef(), {
                name: name.substring(0, 20) || "Anonymous",
                score: score,
                timestamp: serverTimestamp(),
                uid: userId
            });
        } catch (e) {
            console.error("Error adding document: ", e);
            throw e;
        }
    }

    function loadHighScores() {
        if (!db) return;

        // Note: No orderBy used to avoid index requirements, sorting done client-side.
        const q = query(getHighScoresCollectionRef(), where("score", ">", 0));

        onSnapshot(q, (querySnapshot) => {
            const scores = [];
            querySnapshot.forEach((doc) => {
                scores.push(doc.data());
            });

            scores.sort((a, b) => b.score - a.score);

            renderHighScores(scores.slice(0, 10));
        }, (error) => {
            console.error("Error listening to high scores:", error);
            highScoresBody.innerHTML = '<tr><td colspan="3" class="text-center py-2 text-red-500">Failed to load scores.</td></tr>';
        });
    }

    function renderHighScores(scores) {
        highScoresBody.innerHTML = '';

        if (scores.length === 0) {
            highScoresBody.innerHTML = '<tr><td colspan="3" class="text-center py-2 text-gray-500">No high scores yet!</td></tr>';
            return;
        }

        scores.forEach((data, index) => {
            const row = highScoresBody.insertRow();
            row.className = index < 3 ? 'bg-yellow-800/50 font-bold' : 'hover:bg-purple-900/50';

            const rankCell = row.insertCell();
            rankCell.textContent = index + 1;
            rankCell.className = 'py-1 px-3 text-center';

            const nameCell = row.insertCell();
            nameCell.textContent = data.name;
            nameCell.className = 'py-1 px-3 text-left';

            const scoreCell = row.insertCell();
            scoreCell.textContent = data.score;
            scoreCell.className = 'py-1 px-3 text-right';
        });
    }

    // --- Game Logic ---

    /**
     * Resizes the canvas based on its current CSS size in the DOM, 
     * and adjusts the player's Y position accordingly.
     */
    function resizeGame() {
        const rect = canvas.getBoundingClientRect();
        // Set the internal canvas dimensions to match the displayed size
        canvas.width = rect.width;
        canvas.height = rect.height;

        // Adjust player's fixed Y position relative to the new canvas height
        player.y = canvas.height - 30;
        // Keep player's X position clamped to the new width
        player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));

        draw();
    }


    function drawEmoji(emoji, x, y, size) {
        ctx.font = `${size}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, x, y);
    }

    function drawBossAndDevil() {
        const positions = getCharPositions(canvas.width);
        if (nulliBossActive) {
            ctx.shadowColor = '#ff4500';
            ctx.shadowBlur = 15;
            drawEmoji(nulliBossEmoji, positions.DEVIL, 20, 40);
            ctx.shadowBlur = 0;
        } else {
            drawEmoji(devilEmoji, positions.DEVIL, 20, 30);
        }
    }

    function drawAngel() { 
        const positions = getCharPositions(canvas.width);
        if (angelVisible) { drawEmoji(angelEmoji, positions.ANGEL, 20, 30); } 
    }
    function drawJackyna() { 
        const positions = getCharPositions(canvas.width);
        if (jackynaVisible) { drawEmoji(jackynaEmoji, positions.JACKYNA, 20, 30); } 
    }
    function drawZey() { 
        const positions = getCharPositions(canvas.width);
        if (zeyVisible) { drawEmoji(zeyEmoji, positions.ZEY, 20, 30); } 
    }

    function calculateNextJackynaTime() {
        const randomInterval = JACKYNA_MIN_INTERVAL + Math.random() * (JACKYNA_MAX_INTERVAL - JACKYNA_MIN_INTERVAL);
        return performance.now() + randomInterval;
    }

    function calculateNextZeyTime() {
        const randomInterval = ZEY_MIN_INTERVAL + Math.random() * (ZEY_MAX_INTERVAL - ZEY_MIN_INTERVAL);
        return performance.now() + randomInterval;
    }

    function triggerJackynaEffect(currentTime) {
        if (!gameRunning) return;
        // Apply slow effect for 5 seconds (OBJECT_SLOW_DURATION)
        sweets.forEach(sweet => {
            sweet.slowedUntil = currentTime + OBJECT_SLOW_DURATION;
        });
        playSpecialClearSound();
        jackynaVisible = true;
        jackynaHiddenTime = currentTime + JACKYNA_SHOW_DURATION;
        lastJackynaTime = currentTime;
        nextJackynaTime = calculateNextJackynaTime();
    }

    function triggerZeyEffect(currentTime) {
        if (!gameRunning) return;
        // Apply slow effect for 5 seconds (OBJECT_SLOW_DURATION)
        poops.forEach(poop => {
            poop.slowedUntil = currentTime + OBJECT_SLOW_DURATION;
        });
        miniBombs.forEach(bomb => {
            bomb.slowedUntil = currentTime + OBJECT_SLOW_DURATION;
        });
        playSpecialClearSound();
        zeyVisible = true;
        zeyHiddenTime = currentTime + ZEY_SHOW_DURATION;
        lastZeyTime = currentTime;
        nextZeyTime = calculateNextZeyTime();
    }

    function spawnSweet() {
        const x = Math.random() * (canvas.width - 30) + 15;
        const emoji = sweetEmojis[Math.floor(Math.random() * sweetEmojis.length)];
        sweets.push({ x: x, y: 0, size: 18, emoji: emoji, baseSpeed: sweetDropSpeed, slowedUntil: 0 });
    }

    function spawnPoop(emoji = poopEmoji) {
        const x = Math.random() * (canvas.width - 30) + 15;
        poops.push({ x: x, y: 0, size: 18, emoji: emoji, baseSpeed: poopDropSpeed, slowedUntil: 0 });
    }

    function spawnMiniBomb() {
        if (miniBombs.length >= 5) return;
        const x = Math.random() * (canvas.width - 30) + 15;
        miniBombs.push({ x: x, y: 0, size: 22, emoji: '💥', baseSpeed: poopDropSpeed * 1.5, slowedUntil: 0 });
    }

    function spawnPowerUp(currentTime) {
        const positions = getCharPositions(canvas.width);
        // Choose a power-up from the reduced list (no SPEED)
        const drop = angelDrops[Math.floor(Math.random() * angelDrops.length)];

        powerUps.push({
            x: positions.ANGEL,
            y: 40,
            size: 24,
            emoji: drop.emoji,
            speed: powerUpDropSpeed,
            type: drop.type
        });
        angelVisible = true;
        angelHiddenTime = currentTime + ANGEL_SHOW_DURATION;
        lastAngelTime = currentTime; // Reset Mandala Cooldown
    }

    function applyPowerUp(type) {
        powerUpActive = null;

        if (type === 'heart') {
            if (lives < MAX_LIVES) lives++;
            updateHUD();
            return;
        }

        // Apply new timed power-up
        powerUpActive = type;
        powerUpEndTime = performance.now() + POWER_UP_DURATION;
        player.invulnerable = false;

        updateHUD();
    }

    function updatePowerUpEffects(currentTime) {
        // 1. Handle Power-up Expiration
        if (powerUpActive && currentTime > powerUpEndTime) {
            powerUpActive = null;
        }

        // 2. Handle Player Slow Expiration
        if (playerSlowed && currentTime > slowEndTime) {
            playerSlowed = false;
        }

        // 3. Magnet Effect (pull sweets)
        if (powerUpActive === 'magnet') {
            const magnetRange = 80;
            const magnetStrength = 0.5;

            sweets.forEach(sweet => {
                const dx = player.x - sweet.x;
                const dy = player.y - sweet.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < magnetRange) {
                    const angle = Math.atan2(dy, dx);
                    // Pull based on distance from player
                    const pullFactor = magnetStrength * (magnetRange - distance) / magnetRange;

                    sweet.x += Math.cos(angle) * pullFactor * 5;
                    sweet.y += Math.sin(angle) * pullFactor * 5;
                }
            });
        }
    }

    function updateObjects(deltaTime) {
        const factor = deltaTime / 16;
        const currentTime = performance.now();

        // Sweets
        sweets = sweets.filter(sweet => {
            const isSlowed = sweet.slowedUntil && sweet.slowedUntil > currentTime;
            const currentSpeed = isSlowed ? sweet.baseSpeed * SLOW_FACTOR : sweet.baseSpeed;
            sweet.y += currentSpeed * factor;
            // Use canvas.height dynamically
            return sweet.y < canvas.height + sweet.size;
        });

        // Poops
        poops = poops.filter(poop => {
            const isSlowed = poop.slowedUntil && poop.slowedUntil > currentTime;
            const currentSpeed = isSlowed ? poop.baseSpeed * SLOW_FACTOR : poop.baseSpeed;

            poop.y += currentSpeed * factor;
            // Use canvas.height dynamically
            return poop.y < canvas.height + poop.size;
        });

        // Power-ups
        powerUps = powerUps.filter(powerUp => {
            powerUp.y += powerUp.speed * factor;
            // Use canvas.height dynamically
            return powerUp.y < canvas.height + powerUp.size;
        });

        // Mini-Bombs
        miniBombs = miniBombs.filter(bomb => {
            const isSlowed = bomb.slowedUntil && bomb.slowedUntil > currentTime;
            const currentSpeed = isSlowed ? bomb.baseSpeed * SLOW_FACTOR : bomb.baseSpeed;

            bomb.y += currentSpeed * factor;
            // Use canvas.height dynamically
            if (bomb.y >= canvas.height - 10) {
                // Bomb hits the ground - EXPLODE!
                noGoZones.push({
                    x: bomb.x,
                    y: canvas.height - 10,
                    radius: 40,
                    endTime: currentTime + BOMB_EXPLOSION_DURATION
                });
                playHitSound();
                return false;
            }
            return true;
        });

        // No-Go Zones (Remove expired ones)
        noGoZones = noGoZones.filter(zone => zone.endTime > currentTime);
    }

    function checkCollisions() {
        const pRect = { x: player.x - player.size / 2, y: player.y - player.size / 2, width: player.size, height: player.size };
        const currentTime = performance.now();

        const isColliding = (r1, r2) => {
            // Simplified AABB collision for square emojis
            return r1.x < r2.x + r2.width &&
                   r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height &&
                   r1.y + r2.height > r2.y;
        };

        // 1. Sweet Collection
        sweets = sweets.filter(sweet => {
            const sRect = { x: sweet.x - sweet.size / 2, y: sweet.y - sweet.size / 2, width: sweet.size, height: sweet.size };
            if (isColliding(pRect, sRect)) {
                score += 10;
                playCollectSweetSound();
                return false;
            }
            return true;
        });

        // 2. Poop Collision (now includes shield and slow effect)
        poops = poops.filter(poop => {
            const rRect = { x: poop.x - poop.size / 2, y: poop.y - poop.size / 2, width: poop.size, height: poop.size };
            if (isColliding(pRect, rRect)) {
                // Check if shielded
                if (powerUpActive === 'shield') {
                    powerUpActive = null; // Shield breaks
                    return false; // Poop is destroyed
                }

                // Check if invulnerable
                if (!player.invulnerable) {
                    lives--;
                    updateHUD();
                    playHitSound();

                    // STATUS EFFECT: PLAYER SLOW
                    playerSlowed = true;
                    slowEndTime = currentTime + PLAYER_SLOW_DURATION;

                    player.invulnerable = true;
                    setTimeout(() => player.invulnerable = false, 500);

                    if (lives <= 0) { endGame(); }
                    return false; // Poop is destroyed, player hit
                }
                // If player is invulnerable, the poop passes through
                return true;
            }
            return true;
        });

        // 3. Power-Up Collection
        powerUps = powerUps.filter(powerUp => {
            const hRect = { x: powerUp.x - powerUp.size / 2, y: powerUp.y - powerUp.size / 2, width: powerUp.size, height: powerUp.size };
            if (isColliding(pRect, hRect)) {
                playCollectPowerUpSound();
                applyPowerUp(powerUp.type);
                return false;
            }
            return true;
        });

        // 4. Mini-Bomb Collision (immediate explosion on contact)
        miniBombs = miniBombs.filter(bomb => {
            const bRect = { x: bomb.x - bomb.size / 2, y: bomb.y - bomb.size / 2, width: bomb.size, height: bomb.size };
            if (isColliding(pRect, bRect)) {
                // Check if shielded
                if (powerUpActive === 'shield') {
                    powerUpActive = null; // Shield breaks
                    return false; // Bomb is gone, shield broke
                }

                // Check if invulnerable
                if (!player.invulnerable) {
                    lives--;
                    updateHUD();
                    playHitSound();
                    playerSlowed = true;
                    slowEndTime = currentTime + PLAYER_SLOW_DURATION;
                    player.invulnerable = true;
                    setTimeout(() => player.invulnerable = false, 500);
                    if (lives <= 0) { endGame(); }
                    return false; // Bomb is gone on contact, player hit
                }
                // If player is invulnerable, the bomb passes through
                return true;
            }
            return true;
        });

        // 5. No-Go Zone Collision (damage on entry)
        const playerCenter = { x: player.x, y: player.y };
        const playerHitZone = noGoZones.some(zone => {
            const dx = playerCenter.x - zone.x;
            const dy = playerCenter.y - zone.y;
            return (dx * dx + dy * dy) < (zone.radius * zone.radius) &&
                   currentTime < zone.endTime;
        });

        if (playerHitZone && !player.invulnerable && powerUpActive !== 'shield') {
            lives--;
            updateHUD();
            playHitSound();
            playerSlowed = true;
            slowEndTime = currentTime + PLAYER_SLOW_DURATION;
            player.invulnerable = true;
            setTimeout(() => player.invulnerable = false, 500);
            if (lives <= 0) { endGame(); }
        } else if (playerHitZone && powerUpActive === 'shield') {
            powerUpActive = null; // Shield breaks instantly
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const currentTime = performance.now();

        // Helper function for drawing objects with status effects
        const drawFallingObject = (obj) => {
            const isSlowed = obj.slowedUntil && obj.slowedUntil > currentTime;
            let outlineColor = null;

            // Check if it's a hazard emoji (Poop, Mini-Bomb, or the fast bomb 💣)
            const isHazard = [poopEmoji, '💣', '💥'].includes(obj.emoji);

            if (isSlowed) {
                // Cyan for hazards (slowed by Zey), Hot Pink for sweets (slowed by Jackyna)
                outlineColor = isHazard ? 'rgba(0, 255, 255, 0.8)' : 'rgba(255, 105, 180, 0.8)';
            }

            if (outlineColor) {
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, obj.size * 0.8, 0, Math.PI * 2);
                ctx.strokeStyle = outlineColor;
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.closePath();
            }

            drawEmoji(obj.emoji, obj.x, obj.y, obj.size);
        };


        // --- 1. Draw No-Go Zones (Explosions) ---
        noGoZones.forEach(zone => {
            // Fades out the explosion
            const lifeRatio = Math.max(0, (zone.endTime - currentTime) / BOMB_EXPLOSION_DURATION);
            const radius = zone.radius;

            ctx.beginPath();
            ctx.arc(zone.x, zone.y, radius, 0, Math.PI * 2);

            const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, radius);
            gradient.addColorStop(0, `rgba(255, 69, 0, ${0.7 * lifeRatio})`);
            gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.closePath();
        });

        // --- 2. Draw Characters and Items ---
        drawBossAndDevil();
        drawAngel();
        drawJackyna();
        drawZey();

        // Draw falling objects using the helper
        sweets.forEach(drawFallingObject);
        poops.forEach(drawFallingObject);
        miniBombs.forEach(drawFallingObject);

        // Power-ups don't get slowed, so draw normally
        powerUps.forEach(pu => { drawEmoji(pu.emoji, pu.x, pu.y, pu.size); });

        // --- 3. Draw Player and Effects ---
        let playerEmoji = playerSlowed ? '😵' : player.emoji;

        if (powerUpActive === 'shield') {
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size * 1.2, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0, 191, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.closePath();
        }

        // Simplified shadow: Red for invulnerable, default purple otherwise.
        ctx.shadowColor = player.invulnerable ? '#ff0000' : '#a855f7';
        ctx.shadowBlur = player.invulnerable ? 15 : 12;
        drawEmoji(playerEmoji, player.x, player.y, player.size);
        ctx.shadowBlur = 0;
    }

    function increaseDifficulty() {
        const poopSpeedIncrement = 0.02;
        const poopSpeedInterval = 10;

        if (score >= lastPoopSpeedIncreaseScore + poopSpeedInterval) {
            // Base poop speed increase
            poopDropSpeed += poopSpeedIncrement;
            lastPoopSpeedIncreaseScore = Math.floor(score / poopSpeedInterval) * poopSpeedInterval;
        }

        if (score > 0 && score % 50 === 0 && score % 10 !== 0) {
            sweetDropSpeed += 0.1;
            player.baseSpeed += 0.05;
            sweetSpawnRate = Math.max(650, sweetSpawnRate - 10);
        }
    }

    // --- BUTTON Movement Control Functions (USED FOR controlMode == 'buttons') ---
    function startMove(direction) {
        if (!gameRunning) return;
        if (direction === 'left') {
            moveLeft = true;
            moveRight = false;
        } else if (direction === 'right') {
            moveRight = true;
            moveLeft = false;
        }
    }

    function stopMove() {
        moveLeft = false;
        moveRight = false;
    }
    
    // --- TOUCH/DRAG Movement Control Functions (USED FOR controlMode == 'touch') ---
    function handlePointerDown(e) {
        if (!gameRunning || controlMode !== 'touch') return;
        isPointerDown = true;
        handlePointerMove(e); // Set initial position
    }

    function handlePointerMove(e) {
        if (!gameRunning || !isPointerDown || controlMode !== 'touch') return;
        
        // Prevent scrolling on touch devices during move
        e.preventDefault(); 
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        
        // Convert clientX (screen position) to canvas X coordinate
        const rect = canvas.getBoundingClientRect();
        let newX = (clientX - rect.left) / rect.width * canvas.width; 
        
        // Clamp the player position within the canvas boundaries
        newX = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, newX));
        player.x = newX;
    }

    function handlePointerUp() {
        isPointerDown = false;
    }


    function setupButtonListeners() {
        // Remove touch listeners (if any were attached previously)
        canvas.removeEventListener('pointerdown', handlePointerDown);
        canvas.removeEventListener('pointermove', handlePointerMove);
        canvas.removeEventListener('pointerup', handlePointerUp);
        canvas.removeEventListener('pointerleave', handlePointerUp);
        canvas.removeEventListener('touchmove', handlePointerMove);
        canvas.removeEventListener('touchend', handlePointerUp);
        canvas.removeEventListener('touchcancel', handlePointerUp);
        canvas.removeEventListener('touchstart', handlePointerDown);

        controlsContainer.style.display = 'flex';
        
        const moveLeftButton = document.getElementById('move-left');
        const moveRightButton = document.getElementById('move-right');
        
        // Ensure all previous button listeners are removed before re-attaching (cleaner for a real app, though not strictly necessary here since we only call it once in init)
        moveLeftButton.removeEventListener('mousedown', startMove);
        moveLeftButton.removeEventListener('touchstart', startMove);
        moveLeftButton.removeEventListener('mouseup', stopMove);
        moveLeftButton.removeEventListener('mouseleave', stopMove);
        moveLeftButton.removeEventListener('touchend', stopMove);
        moveLeftButton.removeEventListener('touchcancel', stopMove);
        moveRightButton.removeEventListener('mousedown', startMove);
        moveRightButton.removeEventListener('touchstart', startMove);
        moveRightButton.removeEventListener('mouseup', stopMove);
        moveRightButton.removeEventListener('mouseleave', stopMove);
        moveRightButton.removeEventListener('touchend', stopMove);
        moveRightButton.removeEventListener('touchcancel', stopMove);
        

        // Left Button - Attach new listeners
        moveLeftButton.addEventListener('mousedown', () => startMove('left'));
        moveLeftButton.addEventListener('touchstart', (e) => { e.preventDefault(); startMove('left'); });
        moveLeftButton.addEventListener('mouseup', stopMove);
        moveLeftButton.addEventListener('mouseleave', stopMove);
        moveLeftButton.addEventListener('touchend', stopMove);
        moveLeftButton.addEventListener('touchcancel', stopMove);
        
        // Right Button - Attach new listeners
        moveRightButton.addEventListener('mousedown', () => startMove('right'));
        moveRightButton.addEventListener('touchstart', (e) => { e.preventDefault(); startMove('right'); });
        moveRightButton.addEventListener('mouseup', stopMove);
        moveRightButton.addEventListener('mouseleave', stopMove);
        moveRightButton.addEventListener('touchend', stopMove);
        moveRightButton.addEventListener('touchcancel', stopMove);
        
        // Set initial movement state to stopped
        stopMove();
    }
    
    function setupTouchListeners() {
        // Remove button listeners (if any were attached previously)
        controlsContainer.style.display = 'none';

        const moveLeftButton = document.getElementById('move-left');
        const moveRightButton = document.getElementById('move-right');
        
        moveLeftButton.removeEventListener('mousedown', startMove);
        moveLeftButton.removeEventListener('touchstart', startMove);
        moveLeftButton.removeEventListener('mouseup', stopMove);
        moveLeftButton.removeEventListener('mouseleave', stopMove);
        moveLeftButton.removeEventListener('touchend', stopMove);
        moveLeftButton.removeEventListener('touchcancel', stopMove);
        moveRightButton.removeEventListener('mousedown', startMove);
        moveRightButton.removeEventListener('touchstart', startMove);
        moveRightButton.removeEventListener('mouseup', stopMove);
        moveRightButton.removeEventListener('mouseleave', stopMove);
        moveRightButton.removeEventListener('touchend', stopMove);
        moveRightButton.removeEventListener('touchcancel', stopMove);

        // Attach touch/pointer listeners to the canvas
        canvas.addEventListener('pointerdown', handlePointerDown);
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerup', handlePointerUp);
        canvas.addEventListener('pointerleave', handlePointerUp);
        // Fallback for older touch events
        canvas.addEventListener('touchstart', handlePointerDown);
        canvas.addEventListener('touchmove', handlePointerMove);
        canvas.addEventListener('touchend', handlePointerUp);
        canvas.addEventListener('touchcancel', handlePointerUp);
        
        // Set initial movement state to stopped
        isPointerDown = false;
    }

    function setupInputListeners() {
        window.addEventListener('resize', resizeGame);
        
        // Attach the appropriate listeners based on the current mode
        if (controlMode === 'buttons') {
            setupButtonListeners();
        } else {
            setupTouchListeners();
        }
    }
    
    // Function to handle control mode change
    function setControlMode(mode) {
        controlMode = mode;
        // Re-setup listeners to detach the old ones and attach the new ones
        setupInputListeners(); 
    }

    function movePlayer(deltaTime) {
        // Movement is only handled if in 'buttons' mode
        if (controlMode !== 'buttons') {
            // Touch mode handles movement directly in handlePointerMove, 
            // so we do nothing here for touch mode.
            return;
        }
        
        const factor = deltaTime / 16;
        // Use player.speed which is adjusted by effects and slow status
        const step = player.speed * factor;
        let newX = player.x;

        if (moveLeft) {
            newX -= step;
        } else if (moveRight) {
            newX += step;
        } else {
            return; // No movement needed if no button is pressed
        }

        // CRITICAL FIX: Final clamping to prevent passing the walls
        newX = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, newX));
        
        player.x = newX;
    }

    function updateHUD() {
        scoreDisplay.textContent = score;
        // Draw hearts based on lives
        livesDisplay.innerHTML = '❤️'.repeat(Math.min(lives, MAX_LIVES));
        if (lives <= 0) { livesDisplay.innerHTML = '💔'; }

        const currentTime = performance.now();

        // Update player speed and emoji based on active effects
        player.speed = playerSlowed ? player.baseSpeed * 0.5 : player.baseSpeed;

        player.emoji = playerSlowed ? '😵' : '😋';

        // --- HUD Bar Cooldowns ---

        // 1. Mandala Bar (Angel Power-up Cooldown)
        const totalMandalaTime = ANGEL_INTERVAL;
        // How much time has passed since the last power-up drop
        const elapsedTime = currentTime - lastAngelTime;
        const remainingMandalaTime = Math.max(0, ANGEL_INTERVAL - elapsedTime);
        const mandalaPercent = Math.min(100, (remainingMandalaTime / totalMandalaTime) * 100);

        mandalaBar.style.width = `${100 - mandalaPercent}%`;
        // Purple when waiting, Green when ready
        mandalaBar.style.backgroundColor = remainingMandalaTime > 0 ? '#a855f7' : '#10b981';

        // Display countdown for Mandala
        if (remainingMandalaTime > 0) {
            const timeInSeconds = Math.ceil(remainingMandalaTime / 1000);
            mandalaLabel.textContent = `😇 ${timeInSeconds}s`;
        } else {
            mandalaLabel.textContent = '😇 READY';
        }

        // 2. Zey Bar (Poop Clear Cooldown)
        const totalZeyTime = ZEY_MAX_INTERVAL;
        // nextZeyTime is calculated in resetGame/startGame
        const remainingZeyTime = Math.max(0, nextZeyTime - currentTime);
        const zeyPercent = Math.min(100, (remainingZeyTime / totalZeyTime) * 100);

        zeyBar.style.width = `${100 - zeyPercent}%`;
        zeyBar.style.backgroundColor = zeyPercent > 0 ? '#3b82f6' : '#10b981';
        
        // Display countdown for Zey
        if (remainingZeyTime > 0) {
            const timeInSeconds = Math.ceil(remainingZeyTime / 1000);
            zeyLabel.textContent = `🧝‍♀️ ${timeInSeconds}s`;
        } else {
            zeyLabel.textContent = '🧝‍♀️ READY';
        }

        // 3. Jackyna Bar (Sweet Clear Cooldown)
        const totalJackynaTime = JACKYNA_MAX_INTERVAL;
        // nextJackynaTime is calculated in resetGame/startGame
        const remainingJackynaTime = Math.max(0, nextJackynaTime - currentTime);
        const jackynaPercent = Math.min(100, (remainingJackynaTime / totalJackynaTime) * 100);

        jackynaBar.style.width = `${100 - jackynaPercent}%`;
        jackynaBar.style.backgroundColor = jackynaPercent > 0 ? '#ef4444' : '#10b981';

        // Display countdown for Jackyna
        if (remainingJackynaTime > 0) {
            const timeInSeconds = Math.ceil(remainingJackynaTime / 1000);
            jackynaLabel.textContent = `🧙‍♀️ ${timeInSeconds}s`;
        } else {
            jackynaLabel.textContent = '🧙‍♀️ READY';
        }
    }

    function showMessage(title, text, buttons) {
        document.getElementById('messageTitle').textContent = title;
        const llmResponseContainer = document.getElementById('llmResponseContainer');
        llmResponseContainer.classList.add('hidden');
        document.getElementById('llmResponseText').textContent = '';

        let formattedText = text;

        // Simplified text formatting - removed the custom instruction tag logic
        formattedText = text
            .replace(/\n/g, '<br>');

        document.getElementById('messageText').innerHTML = formattedText;

        buttonArea.innerHTML = '';

        buttons.forEach(btn => {
            const button = document.createElement('button');
            button.id = btn.id;
            button.className = `button w-full md:w-auto ${btn.className || ''}`;
            button.textContent = btn.text;
            button.onclick = btn.action;
            button.disabled = false;

            buttonArea.appendChild(button);
        });

        // Ensure leaderboard is hidden initially when message box shows
        leaderboardDisplay.classList.add('hidden');

        messageBox.style.display = 'flex';
    }

    function hideMessage() {
        messageBox.style.display = 'none';
        document.getElementById('llmResponseContainer').classList.add('hidden');
    }

    // --- Game Flow Control ---

    function gameLoop(currentTime) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        // --- BOSS/DEVIL LOGIC ---
        const scoreMilestone = Math.floor(score / BOSS_INTERVAL_SCORE);
        const shouldBeBoss = scoreMilestone > 0 && scoreMilestone % 2 !== 0;

        if (shouldBeBoss && !nulliBossActive) {
            // START BOSS PHASE
            nulliBossActive = true;
            bossEndTime = currentTime + BOSS_DURATION;
            poopDropSpeed *= 1.5; // Boss speed boost
            player.baseSpeed *= 0.7; // Player speed reduction during boss
        }

        if (nulliBossActive && currentTime > bossEndTime) {
            // END BOSS PHASE
            nulliBossActive = false;
            poopDropSpeed /= 1.5;
            player.baseSpeed /= 0.7;
        }

        // Spawning Logic
        if (currentTime - lastSweetTime > sweetSpawnRate) {
            spawnSweet();
            lastSweetTime = currentTime;
        }

        // Poop/Bomb Spawning
        if (nulliBossActive) {
             // Boss always drops fast '💣' poops
             if (currentTime - lastPoopTime > 500) {
                 spawnPoop('💣');
                 lastPoopTime = currentTime;
             }
        } else {
             // Devil (Normal Poop) spawning
             if (currentTime - lastPoopTime > poopSpawnRate) {
                spawnPoop(poopEmoji);
                lastPoopTime = currentTime;
             }
             // Mini-Bomb Spawning
             if (score >= MINI_BOMB_SCORE_START && currentTime - lastBombTime > BOMB_SPAWN_INTERVAL) {
                 spawnMiniBomb();
                 lastBombTime = currentTime;
             }
        }

        // Character Cooldown Logic
        // Mandala (Angel) drops a power-up when cooldown is over AND no power-ups are currently falling
        if (powerUps.length === 0 && currentTime - lastAngelTime > ANGEL_INTERVAL) {
            spawnPowerUp(currentTime);
        }

        if (angelVisible && currentTime > angelHiddenTime) { angelVisible = false; }
        if (jackynaVisible && currentTime > jackynaHiddenTime) { jackynaVisible = false; }
        if (zeyVisible && currentTime > zeyHiddenTime) { zeyVisible = false; }

        if (!jackynaVisible && currentTime >= nextJackynaTime) { triggerJackynaEffect(currentTime); }
        if (!zeyVisible && currentTime >= nextZeyTime) { triggerZeyEffect(currentTime); }

        movePlayer(deltaTime);
        updatePowerUpEffects(currentTime);
        updateObjects(deltaTime);
        checkCollisions();
        increaseDifficulty();
        updateHUD();

        gameLoopId = requestAnimationFrame(gameLoop);
        draw();
    }

    function startGame() {
        if (gameRunning) return;

        resetGame();
        playStartSound();
        gameRunning = true;

        gameLoopId = requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        cancelAnimationFrame(gameLoopId);
        stopAllSounds();
        score = 0;
        lives = 3;
        sweets = [];
        poops = [];
        powerUps = [];
        miniBombs = [];
        noGoZones = [];

        // Reset all effects and timing
        const currentTime = performance.now();
        lastTime = currentTime; // Set lastTime for correct deltaTime on first frame
        lastAngelTime = currentTime; // Reset Mandala timer to start cooldown immediately
        angelVisible = false;
        jackynaVisible = false;
        zeyVisible = false;
        powerUpActive = null;
        playerSlowed = false;
        nulliBossActive = false;
        lastBombTime = 0;
        
        // Reset movement states
        moveLeft = false;
        moveRight = false;
        isPointerDown = false;

        // Initialize next spawn times so HUD bars are correct (start at 0%)
        nextJackynaTime = calculateNextJackynaTime();
        nextZeyTime = calculateNextZeyTime();

        // Reset difficulty
        sweetDropSpeed = 1.4;
        poopDropSpeed = 2.4;
        sweetSpawnRate = 1600;
        poopSpawnRate = 1100;
        player.baseSpeed = 5; 
        player.speed = 5;     
        
        // Reset player position using the dynamically resized canvas width
        player.x = canvas.width / 2;
        lastPoopSpeedIncreaseScore = 0;

        updateHUD();
        draw();
        hideMessage();
    }

    async function submitScoreAndRestart(finalScore) {
        const input = document.getElementById('playerNameInput');
        const name = input ? input.value.trim() : "Anonymous";

        const button = document.getElementById('submitButton');
        if (button) button.disabled = true;

        try {
            await saveHighScore(name, finalScore);
        } catch(err) {
            console.error("Submission failed, proceeding with restart:", err);
        } finally {
            if (button) button.disabled = false;
            startGame();
        }
    }

    function endGame() {
        gameRunning = false;
        cancelAnimationFrame(gameLoopId);
        stopAllSounds();
        playGameOverSound();

        const finalScore = score;

        const messageContent = `The 😈 got you! Your total score is ${finalScore}.<br><br>

Enter your name to record your high score on the permanent, competitive leaderboard:
<div class="mt-3">
    <input type="text" id="playerNameInput" placeholder="Your Name (max 20 chars)" maxlength="20" class="w-full p-2 rounded text-black mb-2 text-base focus:ring-2 focus:ring-yellow-500 focus:outline-none" />
</div>`;

        const buttons = [
            {
                id: 'finalWordButton',
                text: '✨ View Final Word',
                action: () => showFinalWord(finalScore),
                className: 'button-llm'
            },
            {
                id: 'leaderboardButton', // Button to toggle the leaderboard
                text: 'View Top Sweet Collectors 🏆',
                action: () => toggleLeaderboard(document.getElementById('leaderboardButton')),
                className: ''
            },
            {
                id: 'submitButton',
                text: 'Submit Score & Play Again',
                action: () => submitScoreAndRestart(finalScore),
                className: 'button-submit'
            }
        ];

        showMessage("GAME OVER!", messageContent, buttons);
        setTimeout(() => { document.getElementById('playerNameInput')?.focus(); }, 100);
    }

    // --- Initialization & Launcher ---

    function showLauncher() {
        // Hide the loading screen with a fade effect
        loadingScreen.style.opacity = '0';
        setTimeout(() => {
            loadingScreen.style.display = 'none';
            // Show the launcher
            launcherContainer.classList.remove('hidden');
            launcherContainer.style.display = 'flex';
        }, 500); // Wait for the fade transition (0.5s)
    }

    function showGame() {
        launcherContainer.style.display = 'none';
        gameContainer.style.display = 'flex';
        resizeGame(); // Perform initial resize to set up canvas dimensions
        
        // Ensure controls are visible/hidden based on the chosen mode
        if (controlMode === 'buttons') {
            controlsContainer.style.display = 'flex';
        } else {
            controlsContainer.style.display = 'none';
        }
        
        startGame(); // Start the game immediately
    }
    
    // Function to initialize the control mode from the radio buttons
    function initializeControlMode() {
        const selectedMode = document.querySelector('input[name="control-mode"]:checked')?.value || 'buttons';
        controlMode = selectedMode;
        
        // Attach change listeners to update mode dynamically
        document.querySelectorAll('input[name="control-mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                setControlMode(e.target.value);
            });
        });
    }

    function setupLauncher() {
        launchButton.addEventListener('click', () => {
            playLaunchSound();
            setTimeout(showGame, 100);
        });
        
        // Initialize the control mode when the launcher loads
        initializeControlMode();
    }
    
    // NEW: Loading Sequence
    function startLoadingSequence() {
        const duration = 2000; // 2 seconds
        const startTime = performance.now();
        let currentProgress = 0;

        const updateLoading = () => {
            const elapsedTime = performance.now() - startTime;
            let progress = Math.min(100, Math.ceil((elapsedTime / duration) * 100));
            
            if (progress > currentProgress) {
                currentProgress = progress;
                loadingBar.style.width = `${progress}%`;
                loadingText.textContent = `LOADING... ${progress}%`;
            }

            if (progress < 100) {
                requestAnimationFrame(updateLoading);
            } else {
                // Done loading, proceed to launcher
                loadingText.textContent = `LOADING COMPLETE! 100%`;
                setTimeout(showLauncher, 300); // Short delay before fading out
            }
        };

        updateLoading();
    }

    async function init() {
        // Start the loading sequence immediately
        startLoadingSequence();

        // Perform asynchronous setup while the loading bar runs
        // We don't need to await this to block the loading bar, but we ensure it's done before the game starts
        const firebasePromise = setupFirebase();

        // Initial setup for the canvas to ensure it fits the responsive styles
        resizeGame(); 

        setupLauncher();
        // Setup initial listeners based on the mode selected on the launcher screen
        setupInputListeners(); 

        await firebasePromise; // Wait for Firebase setup to finish

        if (db) {
            loadHighScores();
        }

        resetGame(); // This call now correctly initializes the HUD bars and countdowns
    }

    window.onload = init;
</script>
</body>
</html>

