<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>😈 Poopocalypse: Nulli Rising 🧙</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;700&family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    
    

<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.52/Tone.js"></script>
    
    <style>
        /* --- General Variables & Body --- */
        :root {
            --dark-bg: #1a1a2e; /* Dark Navy/Purple */
            --card-bg: #2d2d44; /* Darker Card Background */
            --neon-green: #00f800;
            --gold-title: #ffcc00;
            --text-color: #ffffff;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            margin: 0;
            transition: background-color 0.5s;
        }

        /* --- Launcher Card Styles --- */
        #launcherContainer {
            background-color: var(--card-bg);
            border: 4px solid var(--neon-green);
            box-shadow: 0 10px 30px rgba(0, 255, 0, 0.4);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }
        .main-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            color: var(--gold-title);
            text-shadow: 2px 2px 0 #000000;
            margin-bottom: 1.5rem;
        }
        .description {
            font-size: 0.9rem;
            margin-bottom: 2.5rem;
            color: #c0c0c0;
            line-height: 1.6;
        }
        .launch-button {
            padding: 1rem 2.5rem;
            font-size: 1.1rem;
            font-weight: 700;
            color: black;
            background: linear-gradient(145deg, var(--neon-green), #18a558);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 4px #006400;
            user-select: none;
            text-transform: uppercase;
        }
        .launch-button:hover {
            background: linear-gradient(145deg, #39ff14, #24d673);
            transform: translateY(-2px);
            box-shadow: 0 6px #006400;
        }
        .launch-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px #006400;
        }

        /* --- Game Container Styles (starts hidden) --- */
        #gameContainer {
            display: none; /* Initially hidden */
            background-color: #2d2d44;
            border: 6px solid #00f800;
            box-shadow: 0 8px 20px rgba(0, 255, 0, 0.4);
            border-radius: 18px;
            padding: 0.5rem; 
            max-width: 320px; 
            width: 100%;
            flex-direction: column;
            align-items: center;
            font-family: 'Pixelify Sans', sans-serif;
        }
        canvas {
            display: block;
            background-color: #4a148c; /* Deep Violet Canvas */
            border: 3px solid #ffeb3b; /* Yellow/Gold Inner Border */
            border-radius: 10px;
            margin-top: 0.5rem;
            touch-action: none; /* Prevents touch scrolling/panning interference */
        }
        .info-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0.4rem 0.2rem; 
            font-size: 1rem; 
            font-weight: 700;
            color: #ffffff;
        }
        .game-title {
            font-family: 'Press Start 2P', cursive; 
            font-size: 1.2rem; 
            color: #00f800; 
            text-shadow: 3px 3px 0 #000000; 
            line-height: 1.4;
        }
        .button {
            padding: 0.5rem 1rem; 
            font-size: 0.9rem; 
            font-weight: 700;
            color: black; 
            background: linear-gradient(145deg, #fceb9c, #ffcc00); 
            border: none;
            border-radius: 8px; 
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: 0 3px #cc9900;
            user-select: none;
        }
        /* Styles for Game Over/Message Box */
        .button-llm {
            background: linear-gradient(145deg, #00f800, #18a558); 
            box-shadow: 0 3px #006400;
            color: black;
        }
        
        #messageBox {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            font-family: 'Pixelify Sans', sans-serif; 
            display: none;
        }
        #messageBox > div {
            max-width: 90%;
            padding: 15px;
            background-color: #1a1a2e; 
            border: 2px solid #00f800;
            border-radius: 12px;
            width: 90%; /* Ensure it's responsive */
            max-width: 380px;
        }
        #messageBox h2 {
            font-family: 'Press Start 2P', cursive; 
            font-size: 1.4rem; 
            margin-bottom: 0.5rem;
            color: #ffcc00; 
        }
        .leaderboard-card {
            background-color: #1a1a2e; 
            border: 2px solid #00f800; 
            border-radius: 10px;
            padding: 0.4rem; 
            margin-top: 0.75rem;
            width: 100%;
        }
        #highScoresTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem; 
        }
        #highScoresTable th {
            background-color: #4a148c; 
            color: #ffcc00; 
            padding: 0.3rem; 
            text-align: left;
            font-family: 'Press Start 2P', cursive; 
        }
        #highScoresTable td {
            border-bottom: 1px solid #4a148c;
            color: #c0c0c0; 
            padding: 0.3rem;
        }
        
        /* This style specifically targets the intro message instruction text to use a readable font */
        .intro-instruction {
            font-family: 'Inter', sans-serif !important; 
            font-weight: 700;
            color: #00f800; 
            font-size: 1.1rem;
            display: block; /* To ensure it takes up its own line for emphasis */
            margin-top: 0.75rem;
        }
        
        /* Responsive adjustments */
        @media (max-width: 640px) {
            .main-title {
                font-size: 1.2rem;
            }
            #launcherContainer {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>


<div id="launcherContainer" class="flex flex-col">
    <div class="main-title">😈 POOPOCALYPSE: NULLI RISING 🧙</div>

    <p class="description">
        The dreaded Nulli Clan is on the rise! Play as the heroic collector 😋 in this arcade survival game. Dodge Jehannum's repulsive 💩 and collect vital treats (🍬, 🍭) to survive the Poopocalypse. The leaderboard is shared with all players, so strive for the highest score!
    </p>

    <button id="launchButton" class="launch-button">
        Launch Game Now!
    </button>
</div>


<div id="gameContainer" class="game-container">
    <h1 class="game-title">😈 POOPOCALYPSE: NULLI RISING 🧙</h1>
    
    <div class="info-bar">
        <span>Score: <span id="scoreDisplay">0</span></span>
        <span>Lives: <span id="livesDisplay">❤️ ❤️ ❤️</span></span>
    </div>

    <canvas id="gameCanvas" width="280" height="280"></canvas>
    
    <!-- NEW HUD Panel for Cooldowns -->
    <div id="hudPanel" class="w-full p-2 mt-2 flex justify-around gap-2 text-xs font-bold">
        <div class="flex-1 bg-gray-700 rounded-full overflow-hidden relative h-4">
            <div class="absolute inset-0 text-center text-white z-10">🧙‍♀️ WITCH</div>
            <div id="witchBar" class="h-4 bg-red-500 transition-all duration-100" style="width: 100%;"></div>
        </div>
        <div class="flex-1 bg-gray-700 rounded-full overflow-hidden relative h-4">
            <div class="absolute inset-0 text-center text-white z-10">🧝‍♀️ HEROINE</div>
            <div id="heroineBar" class="h-4 bg-blue-500 transition-all duration-100" style="width: 100%;"></div>
        </div>
    </div>
    
    <div class="leaderboard-card">
        <h2 class="text-base font-bold text-center text-yellow-500 mb-1 font-['Press Start 2P']">🏆 Top Sweet Collectors 🏆</h2>
        <table id="highScoresTable">
            <thead>
                <tr>
                    <th class="rounded-tl-lg">Rank</th>
                    <th>Name</th>
                    <th class="rounded-tr-lg text-right">Score</th>
                </tr>
            </thead>
            <tbody id="highScoresBody">
                <tr><td colspan="3" class="text-center py-2 text-gray-500">Initializing database...</td></tr>
            </tbody>
        </table>
    </div>
</div>


<div id="messageBox">
    <div>
        <h2 id="messageTitle"></h2>
        
        <div id="llmResponseContainer" class="mt-3 hidden">
            <div id="clanLabel" class="text-sm font-bold text-yellow-500 mb-1">Final Word from the Clan:</div> 
            <p id="llmResponseText" class="text-xs text-left p-2 rounded bg-purple-900/50 border border-yellow-700"></p>
        </div>
        
        <p id="messageText" class="mt-3 mb-0"></p>
        
        <div id="buttonArea" class="flex flex-col md:flex-row justify-center items-center gap-2 mt-4">
            

</div>
    </div>
</div>


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, onSnapshot, query, where, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // Set Firestore log level to debug for troubleshooting
    setLogLevel('Debug');
    
    // --- PRE-WRITTEN DIALOGUE (omitted for brevity) ---
    const PRE_WRITTEN_DIALOGUE = {
        high: [
            "Your score is a testament to the divine light! The FA Clan celebrates this monumental sweep of sweetness. Truly a glorious day!",
            "Such grace and dedication! You've soared above the Nulli filth. Keep collecting, for the celestial hoard is ever expanding!",
            "A magnificent feat! You are a beacon of hope against the Poopocalypse. The heavens smile upon your high score of collected treats.",
            "Mandala is impressed! This score is a prayer answered, a perfect harmony of skill and luck. Go forth and shine!",
            "Hark! The Nulli Clan trembles at this total. You have proven that virtue is stronger than vile stench. Excellent work!",
            "Look at those numbers! An ethereal harvest! May your next run bring even greater glory to the FA Clan's cause.",
            "You have achieved true purity of purpose. This high score ensures your name is sung throughout the halls of the heavens!",
            "Divine! The Nulli's attempts were futile against such masterful collection. Keep your spirit bright and your bucket full!",
            "I grant you my blessing for this outstanding result. Your diligence in gathering sweets is an an inspiration to all.",
            "The Poopocalypse is temporarily subdued! Your score shines like a thousand suns. Thank you for your service to the sweet cause."
        ],
        low: [
            "Pitiful! That score is as weak as your defenses. Did you even try to collect any sweets, mortal?",
            "Hahaha! The Nulli Clan is thriving on your incompetence. Come back when you've learned to dodge something other than your responsibilities!",
            "A tragic and pathetic attempt. That meager score barely registers on our chaos meter. Next!",
            "Jehannum is amused! Such a small total means more treats for our side. Enjoy the taste of failure, weakling!",
            "Did you mistake this for a 'poop collector' game? Your score suggests confusion. You are a true embarrassment!",
            "This isn't even worth a taunt. Your score is a joke. Go practice in the nursery, little one.",
            "Your sweet-gathering skills are a blight on the earth. Perhaps you should stick to something simpler, like breathing.",
            "I was hoping for a challenge, and you delivered *this*? Your score is a stain on the leaderboard.",
            "Look at that low number! Did you rage quit or did the Nulli's gifts simply overwhelm your tiny mind?",
            "You are a disappointment to both clans. That score is a monument to your lack of effort. Don't bother returning."
        ]
    };
    
    // --- DOM Elements & Constants ---
    const launcherContainer = document.getElementById('launcherContainer');
    const gameContainer = document.getElementById('gameContainer');
    const launchButton = document.getElementById('launchButton');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const messageBox = document.getElementById('messageBox');
    const highScoresBody = document.getElementById('highScoresBody');
    const buttonArea = document.getElementById('buttonArea'); 
    
    // NEW HUD ELEMENTS
    const witchBar = document.getElementById('witchBar');
    const heroineBar = document.getElementById('heroineBar');

    const CANVAS_WIDTH = 280;
    const CANVAS_HEIGHT = 280;
    const MAX_LIVES = 5; 
    
    // Character cooldowns
    const ANGEL_INTERVAL = 40000;
    const ANGEL_SHOW_DURATION = 1000;
    const WITCH_MIN_INTERVAL = 20000;
    const WITCH_MAX_INTERVAL = 40000;
    const WITCH_SHOW_DURATION = 700;
    const HEROINE_MIN_INTERVAL = 15000;
    const HEROINE_MAX_INTERVAL = 30000;
    const HEROINE_SHOW_DURATION = 500;

    // Game State
    let gameLoopId;
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let playerMoveToX = CANVAS_WIDTH / 2;
    let isPointerDown = false; 
    let lastTime = 0;
    
    let angelVisible = false;
    let angelHiddenTime = 0;
    let lastAngelTime = 0; // For tracking cooldown

    let witchVisible = false;
    let witchHiddenTime = 0;
    let lastWitchTime = 0; // For tracking cooldown
    let nextWitchTime = 0;
    
    let heroineVisible = false;
    let heroineHiddenTime = 0;
    let lastHeroineTime = 0; // For tracking cooldown
    let nextHeroineTime = 0;
    
    let db, auth, userId;
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

    // Player and Objects
    const player = { 
        x: CANVAS_WIDTH / 2, 
        y: CANVAS_HEIGHT - 30, 
        size: 30, 
        emoji: '😋', 
        baseSpeed: 9,
        speed: 9,
        invulnerable: false // For collision buffer after hit/in zone
    };
    
    let sweets = [];
    let poops = [];
    let powerUps = []; // Renamed from hearts
    let miniBombs = [];
    let noGoZones = []; // { x, y, radius, endTime }
    const BOMB_EXPLOSION_DURATION = 2500; // 2.5 seconds
    const MINI_BOMB_SCORE_START = 200;
    let lastBombTime = 0;
    const BOMB_SPAWN_INTERVAL = 3500;
    
    // Status Effects State
    let powerUpActive = null; // 'shield', 'magnet', 'speed'
    const POWER_UP_DURATION = 8000; // 8 seconds
    let powerUpEndTime = 0;
    
    let playerSlowed = false; // Player status
    const PLAYER_SLOW_DURATION = 3000; 
    let slowEndTime = 0;
    
    let heroineSlowActive = false; // Heroine ability status
    const HEROINE_SLOW_DURATION = 3000; 
    let heroineSlowEndTime = 0;
    
    // Boss State
    let nulliBossActive = false;
    const BOSS_INTERVAL_SCORE = 500;
    const BOSS_DURATION = 10000; // 10 seconds
    let bossEndTime = 0;


    // Object properties
    let sweetDropSpeed = 1.4; 
    let poopDropSpeed = 2.4;  
    let powerUpDropSpeed = 0.9; 
    let sweetSpawnRate = 1600; 
    let poopSpawnRate = 1100;
    let lastSweetTime = 0;
    let lastPoopTime = 0;
    let lastPoopSpeedIncreaseScore = 0; 
    
    // Emojis & Positions
    const sweetEmojis = ['🍬', '🍭', '🍩', '🍫', '🍦'];
    const poopEmoji = '💩';
    const devilEmoji = '😈';
    const angelEmoji = '😇'; 
    const witchEmoji = '🧙‍♀️'; 
    const heroineEmoji = '🧝‍♀️'; 
    const nulliBossEmoji = '👹';
    
    const POWER_UP_DROPS = {
        HEART: { emoji: '💖', type: 'heart' },
        SHIELD: { emoji: '🛡️', type: 'shield' },
        MAGNET: { emoji: '🧲', type: 'magnet' },
        SPEED: { emoji: '⚡', type: 'speed' }
    };
    const angelDrops = [POWER_UP_DROPS.HEART, POWER_UP_DROPS.SHIELD, POWER_UP_DROPS.MAGNET, POWER_UP_DROPS.SPEED];

    const CHAR_POSITIONS = {
        ANGEL: CANVAS_WIDTH / 2 - 80,
        HEROINE: CANVAS_WIDTH / 2 - 40,
        DEVIL: CANVAS_WIDTH / 2,
        WITCH: CANVAS_WIDTH / 2 + 40
    };

    let audioContext = null;
    let currentSoundNode = null;

    // --- Sound Logic (omitted helper functions, using direct calls) ---
    function playTone(freq, duration = 0.1, type = 'square', volume = 0.5) {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (currentSoundNode) {
             try { currentSoundNode.stop(); currentSoundNode.disconnect(); } catch(e) {}
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration);
        currentSoundNode = oscillator; 
    }

    function stopAllSounds() {
        if (currentSoundNode) {
            try { currentSoundNode.stop(); currentSoundNode.disconnect(); } catch(e) {}
            currentSoundNode = null;
        }
    }

    function playCollectSweetSound() { playTone(880, 0.05, 'sine', 0.4); }
    function playCollectPowerUpSound() { playTone(1200, 0.1, 'sine', 0.6); } // Used for all drops
    function playHitSound() { playTone(110, 0.4, 'square', 0.8); }
    function playGameOverSound() { playTone(50, 1.5, 'triangle', 0.9); }
    function playStartSound() { playTone(440, 0.05, 'sine'); playTone(660, 0.1, 'sine'); }
    function playSpecialClearSound() { playTone(1500, 0.05, 'sine', 0.3); } 
    function playLaunchSound() { playTone(1046.5, 0.1, 'square', 0.6); } 
    
    // --- Dialogue Generation ---
    function getRandomDialogue(isHigh) {
        if (isHigh) {
            const index = Math.floor(Math.random() * PRE_WRITTEN_DIALOGUE.high.length);
            return {
                text: PRE_WRITTEN_DIALOGUE.high[index],
                characterName: 'Mandala',
                emoji: '😇',
                clanName: 'FA Clan'
            };
        } else {
            const index = Math.floor(Math.random() * PRE_WRITTEN_DIALOGUE.low.length);
            return {
                text: PRE_WRITTEN_DIALOGUE.low[index],
                characterName: 'Jehannum',
                emoji: '😈',
                clanName: 'Nulli Clan'
            };
        }
    }

    function showFinalWord(finalScore) {
        const clanLabel = document.getElementById('clanLabel');
        const llmResponseContainer = document.getElementById('llmResponseContainer'); 
        const llmResponseText = document.getElementById('llmResponseText');
        const finalWordButton = document.getElementById('finalWordButton'); 
        
        const isVisible = !llmResponseContainer.classList.contains('hidden');
        
        if (isVisible) {
            llmResponseContainer.classList.add('hidden');
            llmResponseText.innerHTML = '';
            finalWordButton.textContent = '✨ View Final Word';
        } else {
            const isHighScore = finalScore >= 300; 
            
            try {
                const result = getRandomDialogue(isHighScore);
                const { text, characterName, emoji, clanName } = result;

                llmResponseText.innerHTML = `<strong>${characterName} ${emoji}:</strong> ${text.trim()}`;
                llmResponseContainer.classList.remove('hidden');
                clanLabel.textContent = `Final Word from the ${clanName}:`;
                finalWordButton.textContent = 'Hide Final Word'; 

            } catch (error) {
                console.error("Dialogue generation failed:", error);
                llmResponseText.innerHTML = `**Error:** Internal data error. Try again.`;
                llmResponseContainer.classList.remove('hidden');
            }
        }
    }
    
    // --- Firebase & Firestore Setup (unchanged from previous version) ---

    function getHighScoresCollectionRef() {
        return collection(db, `artifacts/${appId}/public/data/highscores`);
    }

    async function setupFirebase() {
        try {
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            
            auth = getAuth(app);
            
            await setPersistence(auth, browserSessionPersistence);
            
            if (typeof __initial_auth_token !== 'undefined') {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
            
            userId = auth.currentUser?.uid || 'guest-' + crypto.randomUUID();
        } catch (error) {
            console.error("Error setting up Firebase:", error);
        }
    }

    async function saveHighScore(name, score) {
        if (!db || score <= 0) {
            console.error("Firestore not initialized or score too low.");
            return;
        }

        try {
            await addDoc(getHighScoresCollectionRef(), {
                name: name.substring(0, 20) || "Anonymous", 
                score: score,
                timestamp: serverTimestamp(),
                uid: userId
            });
        } catch (e) {
            console.error("Error adding document: ", e);
            throw e; 
        }
    }

    function loadHighScores() {
        if (!db) return;

        const q = query(getHighScoresCollectionRef(), where("score", ">", 0)); 
        
        onSnapshot(q, (querySnapshot) => {
            const scores = [];
            querySnapshot.forEach((doc) => {
                scores.push(doc.data());
            });
            
            scores.sort((a, b) => b.score - a.score);
            
            renderHighScores(scores.slice(0, 10));
        }, (error) => {
            console.error("Error listening to high scores:", error);
            highScoresBody.innerHTML = '<tr><td colspan="3" class="text-center py-2 text-red-500">Failed to load scores.</td></tr>';
        });
    }

    function renderHighScores(scores) {
        highScoresBody.innerHTML = '';
        
        if (scores.length === 0) {
            highScoresBody.innerHTML = '<tr><td colspan="3" class="text-center py-2 text-gray-500">No high scores yet!</td></tr>';
            return;
        }
        
        scores.forEach((data, index) => {
            const row = highScoresBody.insertRow();
            row.className = index < 3 ? 'bg-yellow-800/50 font-bold' : 'hover:bg-purple-900/50';
            
            const rankCell = row.insertCell();
            rankCell.textContent = index + 1;
            rankCell.className = 'py-1 px-3 text-center';
            
            const nameCell = row.insertCell();
            nameCell.textContent = data.name;
            nameCell.className = 'py-1 px-3 text-left';
            
            const scoreCell = row.insertCell();
            scoreCell.textContent = data.score;
            scoreCell.className = 'py-1 px-3 text-right';
        });
    }

    // --- Game Logic ---
    
    function drawEmoji(emoji, x, y, size) {
        ctx.font = `${size}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, x, y);
    }
    
    function drawBossAndDevil() { 
        if (nulliBossActive) {
            ctx.shadowColor = '#ff4500';
            ctx.shadowBlur = 15;
            drawEmoji(nulliBossEmoji, CHAR_POSITIONS.DEVIL, 20, 40); // Nulli Boss (👹)
            ctx.shadowBlur = 0;
        } else {
            drawEmoji(devilEmoji, CHAR_POSITIONS.DEVIL, 20, 30); // Devil (😈)
        }
    }
    
    function drawAngel() { if (angelVisible) { drawEmoji(angelEmoji, CHAR_POSITIONS.ANGEL, 20, 30); } }
    function drawWitch() { if (witchVisible) { drawEmoji(witchEmoji, CHAR_POSITIONS.WITCH, 20, 30); } }
    function drawHeroine() { if (heroineVisible) { drawEmoji(heroineEmoji, CHAR_POSITIONS.HEROINE, 20, 30); } }

    function calculateNextWitchTime() {
        const randomInterval = WITCH_MIN_INTERVAL + Math.random() * (WITCH_MAX_INTERVAL - WITCH_MIN_INTERVAL);
        return performance.now() + randomInterval;
    }
    
    function calculateNextHeroineTime() {
        const randomInterval = HEROINE_MIN_INTERVAL + Math.random() * (HEROINE_MAX_INTERVAL - HEROINE_MIN_INTERVAL);
        return performance.now() + randomInterval;
    }
    
    function triggerWitchEffect(currentTime) {
        if (!gameRunning) return;
        sweets = []; 
        playSpecialClearSound();
        witchVisible = true;
        witchHiddenTime = currentTime + WITCH_SHOW_DURATION; 
        lastWitchTime = currentTime;
        nextWitchTime = calculateNextWitchTime();
    }
    
    function triggerHeroineEffect(currentTime) {
        if (!gameRunning) return;
        poops = []; 
        miniBombs = []; // Heroine clears all poops and bombs!
        playSpecialClearSound();
        heroineVisible = true;
        heroineHiddenTime = currentTime + HEROINE_SHOW_DURATION; 
        lastHeroineTime = currentTime;
        nextHeroineTime = calculateNextHeroineTime();
        
        // --- STATUS EFFECT: HEROINE POOP SLOW ---
        heroineSlowActive = true;
        heroineSlowEndTime = currentTime + HEROINE_SLOW_DURATION; 
    }

    function spawnSweet() {
        const x = Math.random() * (CANVAS_WIDTH - 30) + 15;
        const emoji = sweetEmojis[Math.floor(Math.random() * sweetEmojis.length)];
        sweets.push({ x: x, y: 0, size: 18, emoji: emoji, speed: sweetDropSpeed }); 
    }

    function spawnPoop(emoji = poopEmoji) {
        const x = Math.random() * (CANVAS_WIDTH - 30) + 15;
        poops.push({ x: x, y: 0, size: 18, emoji: emoji, speed: poopDropSpeed }); 
    }
    
    function spawnMiniBomb() {
        if (miniBombs.length >= 5) return;
        const x = Math.random() * (CANVAS_WIDTH - 30) + 15;
        miniBombs.push({ x: x, y: 0, size: 22, emoji: '💥', speed: poopDropSpeed * 1.5 }); // Faster than regular poop
    }

    function spawnPowerUp(currentTime) {
        const drop = angelDrops[Math.floor(Math.random() * angelDrops.length)];
        
        powerUps.push({ 
            x: CHAR_POSITIONS.ANGEL, 
            y: 40, 
            size: 24, 
            emoji: drop.emoji, 
            speed: powerUpDropSpeed,
            type: drop.type // Distinguishes the effect
        });
        angelVisible = true;
        angelHiddenTime = currentTime + ANGEL_SHOW_DURATION;
        lastAngelTime = currentTime;
    }

    function applyPowerUp(type) {
        // Reset power up if already active
        if (powerUpActive === 'speed') player.speed = player.baseSpeed;
        powerUpActive = null;
        
        if (type === 'heart') {
            if (lives < MAX_LIVES) lives++;
            updateHUD();
            return; 
        } 
        
        // Apply new timed power-up
        powerUpActive = type;
        powerUpEndTime = performance.now() + POWER_UP_DURATION;
        player.invulnerable = false; 
        
        if (type === 'speed') {
            player.speed = player.baseSpeed * 2; 
        } 
        // Shield and Magnet effects handled in collision/update logic
        
        updateHUD();
    }
    
    function updatePowerUpEffects(currentTime) {
        // 1. Handle Power-up Expiration
        if (powerUpActive && currentTime > powerUpEndTime) {
            if (powerUpActive === 'speed') {
                player.speed = player.baseSpeed; 
            }
            powerUpActive = null;
        }

        // 2. Handle Player Slow Expiration
        if (playerSlowed && currentTime > slowEndTime) {
            playerSlowed = false;
        }
        
        // 3. Handle Heroine Slow Expiration
        if (heroineSlowActive && currentTime > heroineSlowEndTime) {
            heroineSlowActive = false;
        }

        // 4. Magnet Effect (pull sweets)
        if (powerUpActive === 'magnet') {
            const magnetRange = 80;
            const magnetStrength = 0.5;
            
            sweets.forEach(sweet => {
                const dx = player.x - sweet.x;
                const dy = player.y - sweet.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < magnetRange) {
                    const angle = Math.atan2(dy, dx);
                    // Pull based on distance from player
                    const pullFactor = magnetStrength * (magnetRange - distance) / magnetRange;
                    
                    sweet.x += Math.cos(angle) * pullFactor * 5; // Fixed small pull
                    sweet.y += Math.sin(angle) * pullFactor * 5;
                }
            });
        }
    }

    function updateObjects(deltaTime) {
        const factor = deltaTime / 16; 
        const currentTime = performance.now();
        
        // Apply heroine slow factor to poop speed if active
        const currentPoopSpeed = heroineSlowActive ? poopDropSpeed * 0.3 : poopDropSpeed; 

        // Sweets
        sweets = sweets.filter(sweet => {
            sweet.y += sweet.speed * factor;
            return sweet.y < CANVAS_HEIGHT + sweet.size;
        });

        // Poops
        poops = poops.filter(poop => {
            // Bombs fall faster than normal poops
            const speed = poop.emoji === '💣' ? currentPoopSpeed * 1.5 : currentPoopSpeed;
            poop.y += speed * factor;
            return poop.y < CANVAS_HEIGHT + poop.size;
        });
        
        // Power-ups
        powerUps = powerUps.filter(powerUp => {
            powerUp.y += powerUp.speed * factor;
            return powerUp.y < CANVAS_HEIGHT + powerUp.size;
        });

        // Mini-Bombs
        miniBombs = miniBombs.filter(bomb => {
            bomb.y += bomb.speed * factor;
            if (bomb.y >= CANVAS_HEIGHT - 10) {
                // Bomb hits the ground - EXPLODE!
                noGoZones.push({
                    x: bomb.x,
                    y: CANVAS_HEIGHT - 10,
                    radius: 40,
                    endTime: currentTime + BOMB_EXPLOSION_DURATION
                });
                playHitSound(); 
                return false; 
            }
            return true;
        });

        // No-Go Zones (Remove expired ones)
        noGoZones = noGoZones.filter(zone => zone.endTime > currentTime);
    }

    function checkCollisions() {
        const pRect = { x: player.x - player.size / 2, y: player.y - player.size / 2, width: player.size, height: player.size };
        const currentTime = performance.now();

        const isColliding = (r1, r2) => {
            // Simplified AABB collision for square emojis
            return r1.x < r2.x + r2.width &&
                   r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height &&
                   r1.y + r2.height > r2.y;
        };

        // 1. Sweet Collection
        sweets = sweets.filter(sweet => {
            const sRect = { x: sweet.x - sweet.size / 2, y: sweet.y - sweet.size / 2, width: sweet.size, height: sweet.size };
            if (isColliding(pRect, sRect)) {
                score += 10;
                playCollectSweetSound();
                return false;
            }
            return true;
        });

        // 2. Poop Collision (now includes shield and slow effect)
        poops = poops.filter(poop => {
            const rRect = { x: poop.x - poop.size / 2, y: poop.y - poop.size / 2, width: poop.size, height: poop.size };
            if (isColliding(pRect, rRect)) {
                if (powerUpActive === 'shield') {
                    powerUpActive = null; // Shield breaks
                    return false;
                }
                
                if (!player.invulnerable) {
                    lives--;
                    updateHUD();
                    playHitSound();
                    
                    // --- NEW STATUS EFFECT: PLAYER SLOW ---
                    playerSlowed = true;
                    slowEndTime = currentTime + PLAYER_SLOW_DURATION; 
                    
                    player.invulnerable = true;
                    setTimeout(() => player.invulnerable = false, 500); 

                    if (lives <= 0) { endGame(); }
                }
                return false;
            }
            return true;
        });
        
        // 3. Power-Up Collection
        powerUps = powerUps.filter(powerUp => {
            const hRect = { x: powerUp.x - powerUp.size / 2, y: powerUp.y - powerUp.size / 2, width: powerUp.size, height: powerUp.size };
            if (isColliding(pRect, hRect)) {
                playCollectPowerUpSound();
                applyPowerUp(powerUp.type);
                return false;
            }
            return true;
        });
        
        // 4. Mini-Bomb Collision (immediate explosion on contact)
        miniBombs = miniBombs.filter(bomb => {
            const bRect = { x: bomb.x - bomb.size / 2, y: bomb.y - bomb.size / 2, width: bomb.size, height: bomb.size };
            if (isColliding(pRect, bRect)) {
                if (powerUpActive !== 'shield' && !player.invulnerable) {
                    lives--;
                    updateHUD();
                    playHitSound();
                    playerSlowed = true;
                    slowEndTime = currentTime + PLAYER_SLOW_DURATION; 
                    player.invulnerable = true;
                    setTimeout(() => player.invulnerable = false, 500);
                    if (lives <= 0) { endGame(); }
                }
                powerUpActive = null; // Shield or not, bomb is gone
                return false; 
            }
            return true;
        });
        
        // 5. No-Go Zone Collision (damage on entry)
        const playerCenter = { x: player.x, y: player.y };
        const playerHitZone = noGoZones.some(zone => {
            const dx = playerCenter.x - zone.x;
            const dy = playerCenter.y - zone.y;
            return (dx * dx + dy * dy) < (zone.radius * zone.radius) && currentTime < zone.endTime;
        });
        
        if (playerHitZone && !player.invulnerable) { 
            lives--;
            updateHUD();
            playHitSound();
            playerSlowed = true;
            slowEndTime = currentTime + PLAYER_SLOW_DURATION; 
            player.invulnerable = true;
            setTimeout(() => player.invulnerable = false, 500);
            if (lives <= 0) { endGame(); }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        const currentTime = performance.now();
        
        // --- 1. Draw No-Go Zones (Explosions) ---
        noGoZones.forEach(zone => {
            const radius = zone.radius * (zone.endTime > currentTime ? (zone.endTime - currentTime) / BOMB_EXPLOSION_DURATION : 0); 
            
            ctx.beginPath();
            ctx.arc(zone.x, zone.y, radius, 0, Math.PI * 2);
            
            const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
            gradient.addColorStop(0, 'rgba(255, 69, 0, 0.7)'); 
            gradient.addColorStop(1, 'rgba(255, 69, 0, 0)'); 
            
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.closePath();
        });

        // --- 2. Draw Characters and Items ---
        drawBossAndDevil(); 
        drawAngel(); 
        drawWitch(); 
        drawHeroine(); 
        
        // Draw falling objects
        sweets.forEach(sweet => { drawEmoji(sweet.emoji, sweet.x, sweet.y, sweet.size); });
        poops.forEach(poop => { drawEmoji(poop.emoji, poop.x, poop.y, poop.size); });
        powerUps.forEach(pu => { drawEmoji(pu.emoji, pu.x, pu.y, pu.size); });
        miniBombs.forEach(bomb => { drawEmoji(bomb.emoji, bomb.x, bomb.y, bomb.size); });

        // --- 3. Draw Player and Effects ---
        let playerEmoji = playerSlowed ? '🐢' : player.emoji; // Slowed status 
        
        if (powerUpActive === 'shield') {
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size * 1.2, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0, 191, 255, 0.8)'; 
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.closePath();
        } 
        
        ctx.shadowColor = player.invulnerable ? '#ff0000' : (powerUpActive === 'speed' ? '#00ff00' : '#a855f7');
        ctx.shadowBlur = player.invulnerable ? 15 : 12;
        drawEmoji(playerEmoji, player.x, player.y, player.size);
        ctx.shadowBlur = 0; 
    }
    
    function increaseDifficulty() {
        const poopSpeedIncrement = 0.02; 
        const poopSpeedInterval = 10;
        
        if (score >= lastPoopSpeedIncreaseScore + poopSpeedInterval) {
            // Base poop speed increase
            poopDropSpeed += poopSpeedIncrement;
            lastPoopSpeedIncreaseScore = Math.floor(score / poopSpeedInterval) * poopSpeedInterval;
        }
        
        if (score > 0 && score % 50 === 0 && score % 10 !== 0) {
            sweetDropSpeed += 0.1; 
            player.baseSpeed += 0.05;
            sweetSpawnRate = Math.max(650, sweetSpawnRate - 10);
        }
    }

    function getPointerX(event) {
        if (event.touches && event.touches.length > 0) {
            return event.touches[0].clientX;
        }
        if (event.clientX !== undefined) {
            return event.clientX;
        }
        return null; 
    }

    function setPlayerTarget(event) {
        event.preventDefault(); 
        if (!gameRunning) return; 

        isPointerDown = true; 

        const clientX = getPointerX(event);
        if (clientX === null) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        
        let newX = (clientX - rect.left) * scaleX; 
        
        playerMoveToX = Math.max(player.size / 2, Math.min(CANVAS_WIDTH - player.size / 2, newX));
    }

    function releasePointer(event) {
        if (event.type === 'pointerup' || event.type === 'pointerleave' || event.type === 'touchend' || event.type === 'touchcancel') {
            isPointerDown = false;
        }
    }
    
    function setupInputListeners() {
        canvas.addEventListener('pointerdown', setPlayerTarget);
        canvas.addEventListener('pointermove', setPlayerTarget);
        canvas.addEventListener('pointerup', releasePointer);
        canvas.addEventListener('pointerleave', releasePointer); 
        
        canvas.addEventListener('touchstart', setPlayerTarget);
        canvas.addEventListener('touchmove', setPlayerTarget);
        canvas.addEventListener('touchend', releasePointer);
        canvas.addEventListener('touchcancel', releasePointer);
        
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    }
    
    function movePlayer(deltaTime) {
        if (!isPointerDown) {
            return;
        }

        const factor = deltaTime / 16;
        const dx = playerMoveToX - player.x;
        const distance = Math.abs(dx);
        // Use player.speed which is adjusted by effects
        const step = player.speed * factor; 

        if (distance > step) {
            player.x += Math.sign(dx) * step;
        } else {
            player.x = playerMoveToX;
        }
    }

    function updateHUD() {
        scoreDisplay.textContent = score;
        livesDisplay.innerHTML = '❤️ '.repeat(Math.min(lives, MAX_LIVES));
        if (lives <= 0) { livesDisplay.innerHTML = '💔'; }
        
        const currentTime = performance.now();
        
        // Update player speed and emoji based on active effects
        const currentBaseSpeed = playerSlowed ? player.baseSpeed * 0.5 : player.baseSpeed;
        player.speed = (powerUpActive === 'speed' && !playerSlowed) ? player.baseSpeed * 2 : currentBaseSpeed;
        
        player.emoji = playerSlowed ? '🐢' : '😋';

        // --- HUD Bar Cooldowns ---
        
        const remainingWitchTime = Math.max(0, nextWitchTime - currentTime);
        const totalWitchTime = WITCH_MAX_INTERVAL + WITCH_MIN_INTERVAL / 2; // Average total
        const witchPercent = Math.min(100, (remainingWitchTime / totalWitchTime) * 100);

        const remainingHeroineTime = Math.max(0, nextHeroineTime - currentTime);
        const totalHeroineTime = HEROINE_MAX_INTERVAL + HEROINE_MIN_INTERVAL / 2; // Average total
        const heroinePercent = Math.min(100, (remainingHeroineTime / totalHeroineTime) * 100);
        
        // Witch Bar (Fills up when ready)
        witchBar.style.width = `${100 - witchPercent}%`;
        witchBar.style.backgroundColor = witchPercent > 0 ? '#ef4444' : '#10b981'; 
        
        // Heroine Bar (Fills up when ready)
        heroineBar.style.width = `${100 - heroinePercent}%`;
        heroineBar.style.backgroundColor = heroinePercent > 0 ? '#3b82f6' : '#10b981';
    }

    function showMessage(title, text, buttons) {
        document.getElementById('messageTitle').textContent = title;
        const llmResponseContainer = document.getElementById('llmResponseContainer'); 
        llmResponseContainer.classList.add('hidden');
        document.getElementById('llmResponseText').textContent = '';
        
        const instructionTag = '$$INSTRUCTION$$';
        let formattedText = text;

        if (text.includes(instructionTag)) {
            const parts = text.split(instructionTag);
            
            const instructionHtml = `<span class="intro-instruction">${parts[1]}</span>`;
            
            formattedText = parts[0].replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>') +
                            instructionHtml +
                            parts[2].replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
        } else {
            formattedText = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
        }
            
        document.getElementById('messageText').innerHTML = formattedText;
        
        buttonArea.innerHTML = '';
        
        buttons.forEach(btn => {
            const button = document.createElement('button');
            button.id = btn.id;
            button.className = `button w-full md:w-auto ${btn.className || ''}`;
            button.textContent = btn.text;
            button.onclick = btn.action;
            button.disabled = false;
            
            buttonArea.appendChild(button);
        });
        
        messageBox.style.display = 'flex';
    }

    function hideMessage() {
        messageBox.style.display = 'none';
        document.getElementById('llmResponseContainer').classList.add('hidden');
    }

    // --- Game Flow Control ---

    function gameLoop(currentTime) {
        if (!gameRunning) return;

        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;
        
        // --- BOSS/DEVIL LOGIC ---
        const scoreMilestone = Math.floor(score / BOSS_INTERVAL_SCORE);
        const shouldBeBoss = scoreMilestone > 0 && scoreMilestone % 2 !== 0; 
        
        if (shouldBeBoss && !nulliBossActive) {
            // START BOSS PHASE
            nulliBossActive = true;
            bossEndTime = currentTime + BOSS_DURATION;
            poopDropSpeed *= 1.5; // Boss speed boost
            player.baseSpeed *= 0.7; // Player speed reduction during boss
            player.speed *= 0.7;
            console.log("BOSS START");
        } 
        
        if (nulliBossActive && currentTime > bossEndTime) {
            // END BOSS PHASE
            nulliBossActive = false;
            poopDropSpeed /= 1.5; 
            player.baseSpeed /= 0.7;
            player.speed /= 0.7;
            console.log("BOSS END");
        }
        
        // Spawning Logic
        if (currentTime - lastSweetTime > sweetSpawnRate) {
            spawnSweet();
            lastSweetTime = currentTime;
        }
        
        // Poop/Bomb Spawning
        if (nulliBossActive) {
             // Boss always drops fast '💣' poops
             if (currentTime - lastPoopTime > 500) {
                 spawnPoop('💣'); 
                 lastPoopTime = currentTime;
             }
        } else {
             // Devil (Normal Poop) spawning
             if (currentTime - lastPoopTime > poopSpawnRate) {
                spawnPoop(poopEmoji); 
                lastPoopTime = currentTime;
             }
             // Mini-Bomb Spawning (NEW)
             if (score >= MINI_BOMB_SCORE_START && currentTime - lastBombTime > BOMB_SPAWN_INTERVAL) {
                 spawnMiniBomb();
                 lastBombTime = currentTime;
             }
        }
        
        // Character Cooldown Logic
        if (powerUps.length === 0 && currentTime - lastAngelTime > ANGEL_INTERVAL) {
            spawnPowerUp(currentTime); 
        }
        
        if (angelVisible && currentTime > angelHiddenTime) { angelVisible = false; }
        if (witchVisible && currentTime > witchHiddenTime) { witchVisible = false; }
        if (heroineVisible && currentTime > heroineHiddenTime) { heroineVisible = false; }

        if (!witchVisible && currentTime >= nextWitchTime) { triggerWitchEffect(currentTime); }
        if (!heroineVisible && currentTime >= nextHeroineTime) { triggerHeroineEffect(currentTime); }

        movePlayer(deltaTime);
        updatePowerUpEffects(currentTime); // NEW: Manage timed effects
        updateObjects(deltaTime);
        checkCollisions();
        increaseDifficulty();
        updateHUD(); 

        gameLoopId = requestAnimationFrame(gameLoop);
        draw();
    }
    
    function startGame() {
        if (gameRunning) return;
        
        resetGame();
        playStartSound();
        gameRunning = true;
        
        lastTime = performance.now();
        lastAngelTime = lastTime; 
        lastWitchTime = lastTime;
        lastHeroineTime = lastTime;
        nextWitchTime = calculateNextWitchTime(); 
        nextHeroineTime = calculateNextHeroineTime();
        
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        cancelAnimationFrame(gameLoopId);
        stopAllSounds();
        score = 0;
        lives = 3;
        sweets = [];
        poops = [];
        powerUps = []; 
        miniBombs = [];
        noGoZones = [];

        // Reset all effects and timing
        lastAngelTime = performance.now(); 
        angelVisible = false;
        witchVisible = false;
        heroineVisible = false;
        powerUpActive = null;
        playerSlowed = false;
        heroineSlowActive = false;
        nulliBossActive = false;
        lastBombTime = 0;

        // Reset difficulty
        sweetDropSpeed = 1.4;
        poopDropSpeed = 2.4;
        sweetSpawnRate = 1600;
        poopSpawnRate = 1100;
        player.baseSpeed = 9;
        player.speed = 9;
        player.x = CANVAS_WIDTH / 2;
        playerMoveToX = CANVAS_WIDTH / 2;
        isPointerDown = false;
        lastPoopSpeedIncreaseScore = 0;
        
        updateHUD();
        draw(); 
        hideMessage();
    }

    async function submitScoreAndRestart(finalScore) {
        const input = document.getElementById('playerNameInput');
        const name = input ? input.value.trim() : "Anonymous";
        
        const button = document.getElementById('submitButton');
        if (button) button.disabled = true; 
        
        try {
            await saveHighScore(name, finalScore);
        } catch(err) {
            console.error("Submission failed, proceeding with restart:", err);
        } finally {
            if (button) button.disabled = false;
            startGame();
        }
    }

    function endGame() {
        gameRunning = false;
        cancelAnimationFrame(gameLoopId);
        stopAllSounds();
        playGameOverSound();
        
        const finalScore = score;
        
        const messageContent = `The 😈 got you! Your **total score** is **${finalScore}**.<br><br>

Enter your name to record your high score on the permanent, competitive leaderboard:
<div class="mt-3">
    <input type="text" id="playerNameInput" placeholder="Your Name (max 20 chars)" maxlength="20" class="w-full p-2 rounded text-black mb-2 text-base focus:ring-2 focus:ring-yellow-500 focus:outline-none" />
</div>`;

        const buttons = [
            { 
                id: 'finalWordButton', 
                text: '✨ View Final Word', 
                action: () => showFinalWord(finalScore), 
                className: 'button-llm' 
            },
            { 
                id: 'submitButton', 
                text: 'Submit Score & Play Again', 
                action: () => submitScoreAndRestart(finalScore), 
                className: 'button-submit' 
            }
        ];

        showMessage("GAME OVER!", messageContent, buttons);
        setTimeout(() => { document.getElementById('playerNameInput')?.focus(); }, 100);
    }
    
    function showIntroMessage() {
        const instructionTag = '$$INSTRUCTION$$';
        
        const introText = `Welcome to **😈 Poopocalypse: Nulli Rising 🧙**! You control 😋 to collect treats (🍬, 🍭) and score points! Avoid the repulsive 💩 from evil **Jehannum** (😈) and his explosive **Mini-Bombs** (💥). Every **500 points**, face the terrifying **Nulli Boss** (👹)!

Look for the 😇 angel **Mandala** (drops **Power-Ups** - 🛡️, 🧲, ⚡), the 🧝‍♀️ heroine **Zey** (clears all 💩!), and the 🧙‍♀️ witch **Jackyna** (clears all treats!).

Watch the **HUD bars** for when the Witch and Heroine are ready!

${instructionTag}Move 😋 with your finger to avoid disaster!${instructionTag}`;

        const buttons = [
            { id: 'startButton', text: "Let's Go!", action: startGame, className: 'button-submit' }
        ];

        showMessage(
            "😈 Poopocalypse: Nulli Rising 🧙",
            introText,
            buttons
        );
    }

    // --- Initialization & Launcher ---

    function showGame() {
        launcherContainer.style.display = 'none';
        gameContainer.style.display = 'flex';
        showIntroMessage();
    }
    
    function setupLauncher() {
        launchButton.addEventListener('click', () => {
            playLaunchSound();
            setTimeout(showGame, 100);
        });
    }

    async function init() {
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        
        setupLauncher(); 
        setupInputListeners(); 
        
        await setupFirebase();
        
        if (db) {
            loadHighScores(); 
        }
        
        resetGame();
    }

    window.onload = init;
</script>
</body>
</html>

